/* transformer.js
   Versão corrigida e "à prova de sintaxe" do transformador SysADL -> JavaScript
   Principais garantias:
   - Escapa crases e "${" nos trechos de código gerado
   - Sanitiza nomes vindos do modelo para nomes válidos em JS
   - Gera código com quebras de linha e indentação consistentes
   - Evita avaliação acidental de template literals no tempo de geração
*/

/* helpers locais (não exportados) */
function escapeTemplateLiterals(str) {
  if (str === undefined || str === null) return '';
  // Escapa crases e sequências ${ para não serem avaliadas no momento da geração
  return String(str).replace(/`/g, '\\`').replace(/\$\{/g, '\\${');
}

function sanitizeVarName(name) {
  if (name === undefined || name === null) return '_';
  // Mantém letras, dígitos, _ e $; substitui outros por _
  return String(name).replace(/[^a-zA-Z0-9_$]/g, '_').replace(/^[0-9]/, m => '_' + m);
}

function safePropertyAccess(name) {
  // Retorna uma safe expressão para acessar params["name"] sem dependency de identifier válido
  return 'params["' + String(name).replace(/"/g, '\\"') + '"]';
}

function indent(level) {
  return '    '.repeat(level);
}

/* função de correção pós-geração (extra) - aplica substituições simples sem gerar sintaxe inválida */
function fixSyntax(code) {
  if (typeof code !== 'string') return code;
  // 1) Remove linhas em branco duplicadas
  code = code.replace(/\n{3,}/g, '\n\n');

  // 2) Garante ponto e vírgula nas linhas finais de declarações simples (onde apropriado)
  // (não tenta corrigir lógica complexa — só evita faltas óbvias)
  code = code.replace(/([^\s;{}])\n(?=(?:\s*[A-Za-z_$][A-Za-z0-9_$]*\s*\(|\s*\/\/|\/\*|$))/g, '$1;\n');

  // 3) Remove espaços triplos
  code = code.replace(/[ \t]{3,}/g, '  ');

  return code;
}

/* Função principal chamada pela UI */
async function transformToJavaScript() {
  try {
    const content = (typeof sysadlEditor !== 'undefined' && sysadlEditor.getValue) ? sysadlEditor.getValue() : '';
    if (!content || !content.trim()) {
      if (typeof jsEditor !== 'undefined' && jsEditor.setValue) {
        jsEditor.setValue('// No SysADL code to transform.');
      }
      return;
    }

    console.log('Starting transformation...');
    // parseSysADL deve estar disponível (arquivo parser.js)
    if (typeof parseSysADL !== 'function') {
      throw new Error('parseSysADL() não encontrado — verifique se parser.js foi carregado');
    }
    const parsedData = parseSysADL(content);
    console.log('Parsed data:', parsedData);

    const rawJs = await generateJsCode(parsedData);
    console.log('Generated code before fix (preview):', rawJs.slice(0, 1000));

    const fixed = fixSyntax(rawJs);
    console.log('Generated code after fix (preview):', fixed.slice(0, 1000));

    if (typeof jsEditor !== 'undefined' && jsEditor.setValue) {
      jsEditor.setValue(fixed);
    }
  } catch (err) {
    console.error('Transformation error:', err);
    if (typeof jsEditor !== 'undefined' && jsEditor.setValue) {
      jsEditor.setValue('// Error transforming to JavaScript: ' + (err && err.message ? err.message : String(err)));
    } else {
      throw err;
    }
  }
}

/* Geração segura do JavaScript a partir do modelo parseado */
async function generateJsCode(model) {
  if (!model || typeof model !== 'object') {
    throw new Error('Modelo inválido ou indefinido');
  }

  // Normalizações básicas do modelo para evitar undefined
  model.name = model.name || 'SysADLModel';
  model.components = Array.isArray(model.components) ? model.components : [];
  model.connectors = Array.isArray(model.connectors) ? model.connectors : [];
  model.executables = Array.isArray(model.executables) ? model.executables : [];
  model.constraints = Array.isArray(model.constraints) ? model.constraints : [];
  model.bindings = Array.isArray(model.bindings) ? model.bindings : [];
  model.allocations = Array.isArray(model.allocations) ? model.allocations : [];
  model.activities = Array.isArray(model.activities) ? model.activities : [];

  const code = [];
  const push = line => code.push(line);

  // Header
  push('// @ts-nocheck');
  push('// Generated by transformer.js — Model: ' + String(model.name));
  push('');

  // Utilitários no código gerado (pequeno runtime)
  push('// --- Runtime helpers ---');
  push('function __sleep(ms) { return new Promise(r => setTimeout(r, ms)); }');
  push('class SysADLPort {');
  push('    constructor(name, flowType, direction) {');
  push("        this.name = name;");
  push("        this.flowType = flowType || 'any';");
  push("        this.direction = direction || 'inout';");
  push("        this.value = null;");
  push("        this.bindings = [];");
  push("        this.onDataReceivedCallback = null;");
  push('    }');
  push('');
  push('    addBinding(binding) {');
  push('        this.bindings.push(binding);');
  push("        // log sintético — não use crases aqui para evitar problemas de geração");
  push("        console.log('Binding adicionado à porta ' + this.name);");
  push('    }');
  push('');
  push('    setOnDataReceivedCallback(cb) { this.onDataReceivedCallback = cb; }');
  push('');
  push('    async send(data) {');
  push("        console.log('Porta ' + this.name + ' enviando dados: ' + JSON.stringify(data));");
  push("        if (this.direction !== 'out' && this.direction !== 'inout') {");
  push("            console.error('Direção inválida para envio: ' + this.direction);");
  push('            return false;');
  push('        }');
  push('        if (!this.bindings || this.bindings.length === 0) {');
  push("            console.warn('Nenhum binding associado à ' + this.name);");
  push('            return false;');
  push('        }');
  push('        this.value = data;');
  push('        for (const b of this.bindings) {');
  push('            if (b && b.connector && typeof b.connector.transmit === "function") {');
  push('                await b.connector.transmit(data);');
  push('            }');
  push('        }');
  push('        return true;');
  push('    }');
  push('');
  push('    async receive(data) {');
  push("        console.log('Porta ' + this.name + ' recebendo dados: ' + JSON.stringify(data));");
  push("        if (this.direction !== 'in' && this.direction !== 'inout') {");
  push("            console.error('Direção inválida para recebimento: ' + this.direction);");
  push('            return false;');
  push('        }');
  push('        this.value = data;');
  push('        if (this.onDataReceivedCallback) {');
  push('            await this.onDataReceivedCallback(this.name, data);');
  push('        }');
  push('        return true;');
  push('    }');
  push('');
  push('    getValue() { return this.value; }');
  push('}');
  push('');

  push('class SysADLConnector {');
  push('    constructor(name, transformFn, constraintFn) {');
  push('        this.name = name;');
  push('        this.sourcePort = null;');
  push('        this.targetPort = null;');
  push('        this.transformFn = transformFn || null;');
  push('        this.constraintFn = constraintFn || null;');
  push('        this.queue = [];');
  push('        this.processing = false;');
  push('    }');
  push('');
  push('    setPorts(s, t) { this.sourcePort = s; this.targetPort = t; }');
  push('');
  push('    async transmit(data) {');
  push("        console.log('Conector ' + this.name + ' transmitindo: ' + JSON.stringify(data));");
  push('        const transformed = this.transformFn ? await this.transformFn({ f: data }) : data;');
  push('        this.queue.push(transformed);');
  push('        if (this.processing) return;');
  push('        this.processing = true;');
  push('        while (this.queue.length) {');
  push('            const d = this.queue.shift();');
  push('            if (this.constraintFn) {');
  push('                try {');
  push('                    await this.constraintFn({ input: data, output: d });');
  push('                } catch (e) {');
  push("                    console.error('Constraint failed on connector ' + this.name + ' -> ' + (e && e.message));");
  push('                    continue;');
  push('                }');
  push('            }');
  push('            if (this.targetPort && typeof this.targetPort.receive === "function") {');
  push('                await this.targetPort.receive(d);');
  push('            }');
  push('        }');
  push('        this.processing = false;');
  push('    }');
  push('}');
  push('');

  push('class Binding {');
  push('    constructor(sourceComponent, sourcePort, targetComponent, targetPort, connector) {');
  push('        if (!sourceComponent || !sourcePort || !targetComponent || !targetPort || !connector) {');
  push("            throw new Error('Binding parameters invalid');");
  push('        }');
  push('        this.sourceComponent = sourceComponent;');
  push('        this.sourcePort = sourcePort;');
  push('        this.targetComponent = targetComponent;');
  push('        this.targetPort = targetPort;');
  push('        this.connector = connector;');
  push('        this.sourcePort.addBinding(this);');
  push('        this.connector.setPorts(this.sourcePort, this.targetPort);');
  push('    }');
  push('}');
  push('');

  push('class SysADLComponent {');
  push('    constructor(name, isBoundary) {');
  push('        this.name = name;');
  push('        this.isBoundary = !!isBoundary;');
  push('        this.ports = [];');
  push('        this.state = {};');
  push('        this.activities = [];');
  push('    }');
  push('');
  push('    addPort(port) {');
  push('        this.ports.push(port);');
  push('        port.setOnDataReceivedCallback((pname, data) => this.onDataReceived(pname, data));');
  push('        return port;');
  push('    }');
  push('');
  push('    async onDataReceived(portName, data) {');
  push("        console.log('Component ' + this.name + ' recebeu dados na porta ' + portName);");
  push('        this.state[portName] = data;');
  push('        for (const act of this.activities) {');
  push('            if (act && act.methodName && typeof this[act.methodName] === "function") {');
  push('                await this[act.methodName]();');
  push('            }');
  push('        }');
  push('    }');
  push('');
  push('    async start() {');
  push('        if (this.isBoundary && typeof this.simulateInput === "function") {');
  push('            await this.simulateInput();');
  push('        }');
  push('    }');
  push('}');
  push('');

  // === Component classes ===
  push('// --- Component classes generated from model ---');

  for (const comp of model.components) {
    const compName = sanitizeVarName(comp.name || 'Component');
    const isBoundary = !!comp.isBoundary;
    push('class ' + compName + ' extends SysADLComponent {');
    push('    constructor() {');
    push('        super("' + String(comp.name).replace(/"/g, '\\"') + '", ' + (isBoundary ? 'true' : 'false') + ');');
    // initialize ports
    const ports = Array.isArray(comp.ports) ? comp.ports : [];
    for (const p of ports) {
      const pName = String(p.name || 'port').replace(/"/g, '\\"');
      const pType = String(p.type || 'Real').replace(/"/g, '\\"');
      const pDir = String(p.direction || 'inout').replace(/"/g, '\\"');
      push('        this.addPort(new SysADLPort("' + pName + '", "' + pType + '", "' + pDir + '"));');
      push('        this.state["' + pName + '"] = null;');
    }

    // allocate activities from allocations
    const allocated = (model.allocations || []).filter(a => a.target === comp.name && a.type === 'activity');
    for (const alloc of allocated) {
      const act = (model.activities || []).find(act => act.name === alloc.source);
      if (!act) continue;
      const methodName = 'execute' + sanitizeVarName(act.name);
      push('        this.activities.push({ methodName: "' + methodName + '" });');
    }

    push('    }'); // end constructor
    push('');

    // methods for each allocated activity
    for (const alloc of allocated) {
      const act = (model.activities || []).find(act => act.name === alloc.source);
      if (!act) continue;
      const methodName = 'execute' + sanitizeVarName(act.name);
      push('    async ' + methodName + '() {');
      push('        console.log("Executando atividade ' + String(act.name).replace(/"/g, '\\"') + ' em ' + String(comp.name).replace(/"/g, '\\"') + '");');

      // inputs -> build params object safely
      if (act.inputs) {
        // act.inputs exemplo: "x: Real, y: Real"
        const inputs = String(act.inputs).split(',').map(s => s.trim()).filter(Boolean);
        const paramPairs = inputs.map(inp => {
          const varName = inp.split(':')[0].trim();
          const safe = sanitizeVarName(varName);
          return '"' + varName.replace(/"/g, '\\"') + '": (this.state["' + varName.replace(/"/g, '\\"') + '"] != null ? this.state["' + varName.replace(/"/g, '\\"') + '"] : null)';
        });
        push('        const params = { ' + paramPairs.join(', ') + ' };');
        // debug
        push('        console.log("Parâmetros: " + JSON.stringify(params));');
      } else {
        push('        const params = {};');
      }

      // find executable (executable name in model.executables might be something like act.name + "Ex")
      const executable = (model.executables || []).find(e => e.name && e.name.toLowerCase().indexOf(String(act.name).toLowerCase()) >= 0);
      if (executable) {
        push('        // Chamando executável associado (se existir)');
        push('        const result = await ' + sanitizeVarName(executable.name) + '(params);');
        // constraints
        const constraint = (model.constraints || []).find(c => c.name && c.name.toLowerCase().indexOf(String(act.name).toLowerCase()) >= 0);
        if (constraint) {
          push('        try {');
          // call constraint with safe params mapping and av: result
          const consInputs = String(constraint.inputs || '').split(',').map(s => s.trim()).filter(Boolean);
          const consPairs = consInputs.map(ci => {
            const k = ci.split(':')[0].trim();
            return '"' + k.replace(/"/g, '\\"') + '": (params["' + k.replace(/"/g, '\\"') + '"] != null ? params["' + k.replace(/"/g, '\\"') + '"] : 0)';
          });
          consPairs.push('"av": result');
          push('            await ' + sanitizeVarName(constraint.name) + '({ ' + consPairs.join(', ') + ' });');
          push('        } catch (e) {');
          push('            console.error("Restrição ' + String(constraint.name).replace(/"/g, '\\"') + ' violada: " + (e && e.message));');
          push('            return null;');
          push('        }');
        }

        // output port if exists
        const outputPort = ports.find(p => (p.direction === 'out' || p.direction === 'inout'));
        if (outputPort) {
          const opName = String(outputPort.name).replace(/"/g, '\\"');
          push('        this.state["' + opName + '"] = result;');
          push('        const __port = this.ports.find(xx => xx.name === "' + opName + '");');
          push('        if (__port) { await __port.send(result); }');
        }

        push('        console.log("Atividade ' + String(act.name).replace(/"/g, '\\"') + ' retornou: " + JSON.stringify(result));');
        push('        return result;');
      } else {
        push('        // Nenhum executável encontrado; retornando null');
        push('        return null;');
      }

      push('    }'); // end method
      push('');
    }

    // simulateInput for boundary components
    if (isBoundary) {
      push('    async simulateInput(value = 77.0) {');
      push('        const port = this.ports[0];');
      push('        if (port) {');
      push('            await port.send(value);');
      push('        }');
      push('        await __sleep(1000);');
      push('    }');
      push('');
    }

    push('}'); // end component class
    push('');
  } // end for components

  // === Connector classes ===
  push('// --- Connector classes ---');
  for (const conn of model.connectors) {
    const connName = sanitizeVarName(conn.name || 'Connector');
    // find transform / constraint executables if referenced by name
    const transformFn = conn.transform ? sanitizeVarName(conn.transform) : 'null';
    const constraintFn = conn.constraint ? sanitizeVarName(conn.constraint) : 'null';
    push('class ' + connName + ' extends SysADLConnector {');
    push('    constructor() {');
    push('        super("' + String(conn.name || connName).replace(/"/g, '\\"') + '", ' + (transformFn === 'null' ? 'null' : transformFn) + ', ' + (constraintFn === 'null' ? 'null' : constraintFn) + ');');
    push('    }');
    push('}');
    push('');
  }

  // === System composite class ===
  push('// --- System composite ---');
  push('class SystemCP extends SysADLComponent {');
  push('    constructor() {');
  push('        super("SystemCP", true);');
  push('        this.subComponents = new Map();');
  push('        this.connectors = new Map();');
  push('        this.bindings = [];');

  for (const comp of model.components) {
    if ((comp.name || '').toLowerCase() === 'systemcp') continue;
    const field = sanitizeVarName(String(comp.name || 'comp').toLowerCase());
    push('        this.' + field + ' = new ' + sanitizeVarName(comp.name) + '();');
    push('        this.addSubComponent("' + field + '", this.' + field + ');');
  }
  for (const conn of model.connectors) {
    const cname = sanitizeVarName(conn.name);
    push('        this.addConnector("' + String(conn.name).toLowerCase().replace(/"/g, '\\"') + '", new ' + cname + '());');
  }

  push('        this.configureBindings();');
  push('    }');

  push('');
  push('    addSubComponent(name, component) { this.subComponents.set(name, component); return component; }');
  push('    addConnector(name, connector) { this.connectors.set(name, connector); return connector; }');
  push('    addBinding(binding) { this.bindings.push(binding); }');

  // configureBindings method
  push('');
  push('    configureBindings() {');
  push('        // cria bindings declarados no modelo');
  for (const b of model.bindings) {
    // cada binding tem: sourceComponent, sourcePort, targetComponent, targetPort, connector
    const srcComp = sanitizeVarName(String(b.sourceComponent || '').toLowerCase());
    const tgtComp = sanitizeVarName(String(b.targetComponent || '').toLowerCase());
    const connectorKey = String(b.connector || '').toLowerCase().replace(/"/g, '\\"');

    const sp = String(b.sourcePort || '').replace(/"/g, '\\"');
    const tp = String(b.targetPort || '').replace(/"/g, '\\"');

    push('        try {');
    push('            this.addBinding(new Binding(');
    push('                this.subComponents.get("' + srcComp + '"),');
    push('                this.subComponents.get("' + srcComp + '").ports.find(p => p.name === "' + sp + '"),');
    push('                this.subComponents.get("' + tgtComp + '"),');
    push('                this.subComponents.get("' + tgtComp + '").ports.find(p => p.name === "' + tp + '"),');
    push('                this.connectors.get("' + connectorKey + '")');
    push('            ));');
    push('        } catch (e) { console.error("Erro criando binding: " + (e && e.message)); }');
  }
  push('    }');

  push('');
  push('    async start() {');
  push('        console.log("Iniciando SystemCP e seus subcomponentes...");');
  push('        const arr = Array.from(this.subComponents.values()).map(c => c.start ? c.start() : Promise.resolve());');
  push('        await Promise.all(arr);');
  push('    }');

  push('}'); // end SystemCP
  push('');

  // === Executables (funções helpers) ===
  push('// --- Executables (funções definidas no modelo) ---');
  for (const ex of model.executables) {
    const exName = sanitizeVarName(ex.name);
    // inputs parsing - pega nomes antes dos ":" se houver tipos
    const inputsRaw = String(ex.inputs || '');
    const inames = inputsRaw ? inputsRaw.split(',').map(s => s.split(':')[0].trim()).filter(Boolean) : [];
    push('async function ' + exName + '(params = {}) {');
    push('    try {');
    push('        console.log("Executando ' + String(ex.name).replace(/"/g, '\\"') + ' com params: " + JSON.stringify(params));');
    if (inames.length) {
      // define variáveis locais extraídas de params com nomes sanitizados
      for (const n of inames) {
        const safe = sanitizeVarName(n);
        push('        const ' + safe + ' = (params["' + n.replace(/"/g, '\\"') + '"] !== undefined ? params["' + n.replace(/"/g, '\\"') + '"] : null);');
      }
    }
    // body: escapar crases e ${ para não quebrar a geração; assumimos body é texto JS confiável do parser
    const body = ex.body ? escapeTemplateLiterals(String(ex.body)) : '// body vazio';
    // indent body lines
    const bodyLines = body.split('\n').map(l => '        ' + l);
    push(...bodyLines);
    push('    } catch (e) { console.error("Erro em ' + exName + ': " + (e && e.message)); throw e; }');
    push('}');
    push('');
  }

  // === Constraints ===
  push('// --- Constraints ---');
  for (const cons of model.constraints) {
    const consName = sanitizeVarName(cons.name);
    // equation será usado como expressão JS após mapear tokens para params["..."]
    let equation = String(cons.equation || '').trim();
    // substitui identificadores por accesso seguro params["id"] (bastante conservador)
    equation = equation.replace(/\b([A-Za-z_][A-Za-z0-9_]*)\b/g, (m) => {
      // se for palavra-chave JS, mantém
      if (['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'].includes(m)) return m;
      // se for número, mantem
      if (/^\d+(\.\d+)?$/.test(m)) return m;
      return 'params["' + m + '"]';
    });

    push('async function ' + consName + '(params = {}) {');
    push('    try {');
    push('        console.log("Avaliando restrição ' + String(cons.name).replace(/"/g, '\\"') + '");');
    push('        const result = (' + (equation || 'false') + ');');
    push('        if (!result) { throw new Error("Restrição ' + String(cons.name).replace(/"/g, '\\"') + ' violada"); }');
    push('        return result;');
    push('    } catch (e) { console.error("Erro em constraint ' + consName + ': " + (e && e.message)); throw e; }');
    push('}');
    push('');
  }

  // === Main ===
  push('// --- Main ---');
  push('async function main() {');
  push('    console.log("Iniciando simulação do ' + String(model.name).replace(/"/g, '\\"') + '");');
  push('    const system = new SystemCP();');
  push('    await system.start();');
  push('    console.log("Simulação finalizada");');
  push('}');
  push('');
  push('main().catch(err => console.error("Erro na execução principal: " + (err && err.message)));');

  // monta final
  const finalCode = code.join('\n');

  // aplica um fix sintático leve
  return fixSyntax(finalCode);
}

/* Export / disponibilização global para uso pela UI (index.html) */
if (typeof window !== 'undefined') {
  window.transformToJavaScript = transformToJavaScript;
  window.generateJsCode = generateJsCode;
  window.fixSyntax = fixSyntax;
}
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    transformToJavaScript,
    generateJsCode,
    fixSyntax
  };
}
