/*
  * =============================================================================
  * Gramática SysADL Completa (com Viewpoints de Ambiente e Cenário)
  * Convertida de Xtext para Peggy.js (Versão Definitiva e Completa)
  * =============================================================================
  * Esta gramática traduz a estrutura completa da linguagem SysADL, incluindo
  * os pontos de vista Estrutural, Comportamental, Executável e os novos
  * pontos de vista de Ambiente e Cenário.
  *
  * NOTA: A resolução de referências (scoping), que no Xtext é feita com `[Type|ID]`,
  * é representada aqui pela captura do nome (ex: `QualifiedName`). A lógica para
  * ligar este nome ao seu objeto de definição correspondente deve ser
  * implementada numa fase de pós-processamento (análise semântica) após o parsing.
  * =============================================================================
  */

  {
    // Bloco de inicialização do Peggy.js (se necessário)
  }

  // =============================================================================
  // --- Regra Inicial ---
  // =============================================================================

  start
    = _ model:Model _ { return model; }

  // =============================================================================
  // --- Estrutura Principal do Modelo ---
  // =============================================================================

  Model
    = "Model" _ name:ID _ ";" _
      involvedElements:("using" _ el:QualifiedName _ ";" _ { return el; })*
      members:(
        _ m:(
            Property /
            Package /
            Requirement /
            Style /
            // --- NOVOS ELEMENTOS ADICIONADOS AQUI ---
            EnvironmentDefinition /
            EnvironmentConfiguration /
            EventsDefinitions /
            SceneDefinitions /
            ScenarioDefinitions /
            ScenarioExecution
          ) _ { return m; }
      )*
      allocation:(_ allocation:AllocationTable { return allocation; })?
      {
        return {
          type: "Model",
          name,
          involvedElements,
          members,
          allocation,
          location: location()
        };
      }

  // =============================================================================
  // --- Estilos (Styles) ---
  // =============================================================================

  Style
    = "style" _ name:QualifiedName _ "{" _
      members:(
        _ m:(Invariant / AbstractDef / Function) _ { return m; }
      )*
      _ "}"
      {
        return { type: "Style", name, members, location: location() };
      }

  Function
    = "function" _ name:ID _ def:("=" _ d:STRING { return d; })?
      {
        return { type: "Function", name, def: def || null, location: location() };
      }

  Invariant
    = "invariant" _ name:ID _ expr:("=" _ e:STRING { return e; })?
      {
        return { type: "Invariant", name, expr: expr || null, location: location() };
      }

  // =============================================================================
  // --- Definições Abstratas (Abstract) ---
  // =============================================================================

  AbstractDef
    = def:(AbstractComponentDef / AbstractConnectorDef / AbstractActivityDef / AbstractProtocol)
      { return def; }

  AbstractActivityDef
    = "abstract" _ "activity" _ "def" _ name:ID
      // a seguir, opcionalmente, assinatura completa + bloco
      signature:
        (
          // parâmetros de entrada (um ou mais)
          inParams:( _ "(" _ PinList? _ ")" )+
          // parâmetros de saída
          outParams:( _ ":" _ "(" _ PinList? _ ")" )?
          // corpo
          _ "{" _ body:ActivityBody _ "}" _
        )?
      {
        // se não houver 'signature', é só uma declaração
        if (!signature) {
          return {
            type:         "AbstractActivityDef",
            name,
            inParameters: [],
            outParameters: [],
            body:         null,
            location:     location()
          };
        }
        // caso haja assinatura+bloco, extrai os valores
        const [, inParams, outParams, body] = signature;
        return {
          type:         "AbstractActivityDef",
          name,
          // inParams: cada p tem PinList em p[3]
          inParameters: inParams.map(p => p[3] || []),
          // outParams: PinList aparece em index 5 (por causa do ":" e parênteses)
          outParameters: outParams ? outParams[5] || [] : [],
          body,
          location:     location()
        };
      }

  AbstractComponentDef
    = "abstract" _ "component" _ "def" _ name:ID _ bounds:Bounds? _
      "{" _
      ports:
        (
          _ "ports" _ ":" _
          ps:(_ AbstractPortUse)*    // zero ou mais usos de porta, sempre pulando whitespace antes
          {
            return ps.map(item => item[1]);
          }
        )?
      composition:
        (_ "compose" _ "{" _ c:QualifiedNameList _ "}"
          { return c; }
        )?
      _ "}"
      {
        return {
          type: "AbstractComponentDef",
          name,
          bounds,
          ports: ports || [],
          composition,
          location: location()
        };
      }

  AbstractPortUse
    = name:ID _ ":" _ flowProperty:FlowProperty _ "any" _ bounds:Bounds?
      {
        return { type: "AbstractPortUse", name, flowProperty, bounds, location: location() };
      }

  AbstractConnectorDef
    = "abstract" _ "connector" _ "def" _ name:ID _
      "{" _
      ports:
        ( _ "participants" _ ":" _
          first:AbstractPortUse_Reverse
          rest:(_ AbstractPortUse_Reverse)*
          {
            return [ first, ...rest.map(r => r[1]) ];
          }
        )?
      flows:( _ "flows" _ ":" _ f:AbstractFlow* { return f; })?
      _ "}"
      {
        return {
          type: "AbstractConnectorDef",
          name,
          ports: ports || [],
          flows: flows || [],
          location: location()
        };
      }



  AbstractFlow
    = "flow" _ source:ID _ "to" _ target:ID _ ";"?
      {
        return { type: "AbstractFlow", source, target, location: location() };
      }

  AbstractPortUse_Reverse
    = "~" _ name:ID _ ":" _ flowProperty:FlowProperty _ "any"
      {
        return { type: "AbstractPortUse", isReverse: true, name, flowProperty, location: location() };
      }

  AbstractProtocol
    = "activity" _ "protocol" _ name:ID _ "{" _ body:AbstractProtocolBody _ "}"
      {
        return { type: "AbstractProtocol", name, body, location: location() };
      }

  AbstractProtocolBody
    = recControl:ProtocolControl _ body:AbstractProtocolBodyInternal _ recursive:(recType:ProtocolAlternativeType _ r:AbstractProtocolBody { return { recType, recursive: r }; })?
      {
        return { type: "AbstractProtocolBody", recControl, body, recursive, location: location() };
      }

  AbstractProtocolBodyInternal
    = "(" _ body:AbstractProtocolBody _ ")" { return body; }
    / AbstractActionSend
    / AbstractActionReceive

  AbstractActionSend
    = "send" _ "any" _ "via" _ flowTo:QualifiedName
      {
        return { type: "AbstractActionSend", flowTo, location: location() };
      }

  AbstractActionReceive
    = "receive" _ "any" _ "from" _ flowTo:QualifiedName
      {
        return { type: "AbstractActionReceive", flowTo, location: location() };
      }

  AbstractPin
    = name:ID _ ":" _ isFlow:("flow" _)? "any" _ arrayIndex:Index?
      {
        return { type: "AbstractPin", name, isFlow: !!isFlow, arrayIndex, location: location() };
      }

  // =============================================================================
  // --- Pacotes e Requisitos ---
  // =============================================================================

  Package
    = "package" _ name:QualifiedName _
      appliedStyle:("uses" _ s:QualifiedNameList)? _
      "{" _
      imports:("import" _ i:QualifiedName _ ";" _ { return i; })*
      importedDefinitions:("using" _ d:QualifiedName _ ";" _ { return d; })*
      definitions:(
        _ d:(Property / ElementDef / ArchitectureDef) _ { return d; }
      )*
      _ "}"
      {
        return {
          type: "Package",
          name,
          appliedStyle,
          imports,
          importedDefinitions,
          definitions,
          location: location()
        };
      }

  Requirement
    = "Requirement" _ name:ID _ "(" _ id:ReqNumber _ ")" _
      "{" _
      text:(_ "text" _ "=" _ t:EString { return t; })?
      satisfiedBy:(_ "satisfied" _ "by" _ s:QualifiedNameList _ ";" { return s; })?
      derive:(_ "derive" _ d:QualifiedNameList _ ";" { return d; })?
      members:(
        _ m:(Property / Requirement) _ { return m; }
      )*
      _ "}"
      {
        return { type: "Requirement", name, id, text, satisfiedBy, derive, members, location: location() };
      }

  ReqNumber
    = head:INT tail:("." t:INT { return t; })*
      { return [head, ...tail].join('.'); }

  // =============================================================================
  // --- Definições de Elementos Principais ---
  // =============================================================================

  ElementDef
    = def:(
        DataTypeDef / DimensionDef / UnitDef / ValueTypeDef / Enumeration /
        ComponentDef / ConnectorDef / PortDef /
        ActionDef / ActivityDef / Protocol / ConstraintDef / Executable
      )
      { return def; }

  TypeDef
    = def:(DataTypeDef / ValueTypeDef / Enumeration)
      { return def; }

  StructuralDef
    = def:(ComponentDef / ConnectorDef / PortDef)
      { return def; }

  DataDef
    = def:(DataTypeDef / DimensionDef / UnitDef / ValueTypeDef / Enumeration)
      { return def; }

  BehaviorDef
    = def:(ActivityDef / Protocol / ConstraintDef / ActionDef)
      { return def; }

  ArchitectureDef
    = "architecture" _ "def" _ name:ID _
      appliedStyle:("styles" _ s:QualifiedNameList)? _
      "{" _
      _ "ports" _ ":" _ ports:PortUse*
      properties:(_ p:Property { return p; })*
      composite:(_ c:Configuration { return c; })
      _ "}"
      {
        return { type: "ArchitectureDef", name, appliedStyle, ports, properties, composite, location: location() };
      }

  // =============================================================================
  // --- Ponto de Vista Estrutural ---
  // =============================================================================

  ComponentDef
    = isBoundary:("boundary" _)? "component" _ "def" _ name:ID _
      appliedStyle:("styles" _ s:QualifiedNameList)? _
      abstractComponent:("implements" _ ac:QualifiedName { return ac; })? _
      "{" _
      ports:
        (_ "ports" _ ":" _
          ps:(_ PortUse)*   
        {
          return ps.map(item => item[1]);
        }
        )?
      members:
        (
          _ m:(Property / StructuralDef / DataDef)
          { return m; }
        )*
      composite:
        (
          _ c:Configuration
          { return c; }
        )?
      _ "}"
      {
        return { type: "ComponentDef", isBoundary: !!isBoundary, name, appliedStyle, abstractComponent: abstractComponent || null, ports: ports || [], members, composite, location: location() };
      }

  ConnectorDef
    = "connector" _ "def" _ name:ID _ abstractConnector:("implements" _ ac:QualifiedName { return ac; })? _
      "{" _
      ports:
        (
          _ "participants" _ ":" _
          ps:(_ PortUse_Reverse)*      // zero ou mais PortUse_Reverse, com skip antes de cada um
          {
            return ps.map(item => item[1]);
          }
        )?
      composite:( _ Configuration)? 
      flows:(_ "flows" _ ":" _ f:Flow* { return f; })?
      members:(Property / StructuralDef / DataDef)*
      _ "}"
      {
        return { type: "ConnectorDef", name, abstractConnector: abstractConnector || null, ports: ports || [], composite, flows: flows || [], members, location: location() };
      }

  PortDef
    = def:(CompositePortDef / SimplePortDef) { return def; }

  CompositePortDef
  = "port" _ "def" _ name:ID _
      "{" _
      ports:
        (
          _ "ports" _ ":" _
          ps:(_ PortUse)*       // zero ou mais, com skip antes de cada um
          {
            return ps.map(item => item[1]);
          }
        )?
      members:(Property / StructuralDef / DataDef)*
      _ "}"
      {
        return { type: "CompositePortDef", name, ports: ports || [], members, location: location() };
      }

  SimplePortDef
    = "port" _ "def" _ name:ID _
      "{" _
      _ "flow" _ flowProperties:FlowProperty _ flowType:QualifiedName _ arrayIndex:Index?
      members:(Property / StructuralDef / DataDef)*
      _ "}"
      {
        return { type: "SimplePortDef", name, flowProperties, flowType, arrayIndex, members, location: location() };
      }

  Configuration
    = "configuration" _
      "{" _
      components:(_ "components" _ ":" _ c:ComponentUse_List)?
      connectors:(_ "connectors" _ ":" _ n:ConnectorUse_List)?
      delegations:(_ "delegations" _ ":" _ d:Delegation*)?
      _ "}" _
      {
        return { type: "Configuration", components: components || [], connectors: connectors || [], delegations: delegations || [], location: location() };
      }

  ComponentUse_List
    = components:(_ &(!("connectors" _ / "delegations" _ / "}")) c:ComponentUse { return c; })*
      { return components; }

  ConnectorUse_List
    = connectors:(_ &(!("delegations" _ / "}")) c:ConnectorUse { return c; })*
      { return connectors; }

  ComponentUse
    = name:ID _ ":" _ definition:QualifiedName _ bounds:Bounds? _
      body:("{" _
        ports:
          ("using" _ "ports" _ ":" _
            head:PortUse
            tail:(_ PortUse)*
          {
            return [head, ...tail.map(t => t[1])];
          }
          )?
        properties:Property*
      _ "}" / ";")
      {
        return { type: "ComponentUse", name, definition, bounds, body, location: location() };
      }

  ConnectorUse
    = name:ID _ ":" _ definition:QualifiedName _ bounds:Bounds? _
      bindings:("bindings" _ b:ConnectorBindingList)? _
      body:("{" _
        _ "ports" _ ":" _ ports:PortUse_Reverse*
        properties:Property*
      _ "}" / ";")
      {
        return { type: "ConnectorUse", name, definition, bounds, bindings, body, location: location() };
      }

  PortUse
    = name:ID _ ":" _ definition:QualifiedName _ concrete:("concrete" _ c:QualifiedName { return c; })? _ bounds:Bounds? _
      body:("{" _ properties:Property* _ "}" / ";")
      {
        return { type: "PortUse", name, definition, concrete: concrete || null, bounds, body, location: location() };
      }

  PortUse_Reverse
    = "~" _ port:PortUse { return { ...port, isReverse: true }; }

  Delegation
    = source:QualifiedName _ "to" _ destination:QualifiedName _ ";"? _
      {
        return { type: "Delegation", source, destination, location: location() };
      }

  Flow
    = flowType:QualifiedName _ "from" _ source:QualifiedName _ "to" _ destination:QualifiedName _ ";"?
      {
        return { type: "Flow", flowType, source, destination, location: location() };
      }

  ConnectorBinding
    = source:QualifiedName _ "=" _ destination:QualifiedName
      {
        return { type: "ConnectorBinding", source, destination, location: location() };
      }

  // =============================================================================
  // --- Ponto de Vista de Dados ---
  // =============================================================================

  AttributeUse
    = "^" _ tu:TypeUse { return tu; }
    / tu:TypeUse      { return tu; }
    
DataTypeDef
  = "datatype" _ name:ID _ superType:("extends" _ s:QualifiedName { return s; })? _
    "{" _
    attributes:
      (
        _ "attributes" _ ":" _
        attrs:( _ AttributeUse )*
        {
          return attrs.map(a => a[1]);
        }
      )?
    properties:Property*
    _ "}"
    {
      return {
        type:       "DataTypeDef",
        name,
        superType: superType || null,
        attributes: attributes || [],
        properties,
        location:   location()
      };
    }
  ValueTypeDef
    = "value" _ "type" _ name:ID _ superType:("extends" _ s:QualifiedName { return s; })? _
      "{" _
      unit:("unit" _ "=" _ u:QualifiedName { return u; })? _
      dimension:("dimension" _ "=" _ d:QualifiedName { return d; })? _
      properties:( _ Property )*
      _ "}"
      {
        return { type: "ValueTypeDef", name, superType: superType || null, unit: unit || null, dimension: dimension || null, properties, location: location() };
      }

  Enumeration
    = "enum" _ name:ID _ "{" _
      properties:Property*
      literals:EnumLiteralValueList
      _ "}"
      {
        // garantir que 'literals' seja um array (compatível com o analisador/semântica)
        const literalItems = literals
          ? (Array.isArray(literals) ? literals : (literals.items || []))
          : [];
        return { type: "Enumeration", name, properties, literals: literalItems, location: location() };
      }

  EnumLiteralValue
    = name:ID { return { type: "EnumLiteralValue", name, location: location() }; }

  DimensionDef
    = "dimension" _ name:ID _ body:("{" _ props:Property* _ "}")?
      { return { type: "DimensionDef", name, properties: body ? body.props : [], location: location() }; }

  UnitDef
    = "unit" _ name:ID _ body:("{" _
        dimension:("dimension" _ "=" _ d:QualifiedName)?
        props:Property*
      _ "}")?
      { return { type: "UnitDef", name, dimension: body ? body.dimension : null, properties: body ? body.props : [], location: location() }; }

  // =============================================================================
  // --- Ponto de Vista Comportamental e Executável ---
  // =============================================================================

  ConstraintUse
    = kind:ConstraintKind _ definition:QualifiedName
      { return { type: "ConstraintUse", kind, definition, location: location() }; }

  ConstraintKind
    = kind:("pre-condition" / "post-condition" / "invariant") { return kind; }

  //ParamList
  //  = params:(Param ( _ "," _ Param )* )? {
  //     return params
  //        ? [ params[0], ...params[1].map(r => r[3]) ]
  //        : [];
  //    }

  //Param
  //  = name:ID _ ":" _ type:QualifiedName {
  //      return { name, type };
  //    }

  // --- antes: defina Pin e as outras regras (Property, BehaviorDef, DataDef, ConstraintUse, ActivityDelegation) ---

  ActionDef
    = "action" _ "def" _ name:ID _ "(" _ inParameters:PinList _ ")" _ ":" _ returnType:QualifiedName _ "{" _
      stmts:(
        _ stmt:(
          Property
        / BehaviorDef
        / DataDef
        / (_ "constraint" _ ":" _
            first:ConstraintUse
            rest:( _ ConstraintUse )*
          {
            return [ first, ...rest.map(r => r[1]) ];
          }
          )      
        / ActivityDelegation
        )
        { return stmt; }
      )*
      _ "}"
      {
        // monte o AST igual antes, usando inParameters direto
        const properties    = stmts.filter(s => s.type === "Property");
        const behaviorDefs  = stmts.filter(s => s.type === "BehaviorDef");
        const dataDefs      = stmts.filter(s => s.type === "DataDef");
        const constraints   = stmts.filter(Array.isArray).flat();
        const delegations   = stmts.filter(s => s.type === "ActivityDelegation");
        return {
          type:        "ActionDef",
          name,
          inParameters,     // aqui vem o array montado pela sua PinList
          returnType,
          properties,
          behaviorDefs,
          dataDefs,
          constraints,
          delegations,
          location:    location()
        };
      }

  ActivityDef
    = "activity" _ "def" _ name:ID
      abstractActivity:( _ "implements" _ ac:QualifiedNameList )?  // implements opcional
      _                                                            // SKIP extra
      inParams:( _ "(" _ PinList? _ ")" )*                          // zero ou mais in-params
      outParams:( _ ":" _ "(" _ PinList? _ ")" )?                   // optional out-params
      _ "{" _
        body:ActivityBody?    // agora opcional
      _ "}"    {
        return {
          type:           "ActivityDef",
          name,
          implements:     abstractActivity ? abstractActivity[3] : [],
          // cada inParam tem PinList em p[3]
          inParameters:   inParams.map(p => p[3] || []),
          // outParams: PinList está em index 5 (por causa do ":" + parênteses)
          outParameters:  outParams ? outParams[5] || [] : [],
          body:           body   || null,
          location:       location()
        };
      }


  Protocol
    = "protocol" _ name:ID _ "(" _ inParameters:PinList? _ ")" _ outParameters:(":" _ "(" _ p:PinList? _ ")")? _
      "{" _
      members:(Property / BehaviorDef / DataDef)*
      delegations:(_ "delegations" _ ":" _ d:ActivityDelegation*)?
      body:ProtocolBody
      _ "}"
      {
        return { type: "Protocol", name, inParameters: inParameters || [], outParameters, members, delegations, body, location: location() };
      }

  ConstraintDef
    = "constraint" _ name:ID _
      inParameters:("(" _ p:PinList? _ ")")? _
      outParameters:(":" _ "(" _ p:PinList? _ ")")? _
      "{" _
      members:(Property / BehaviorDef / DataDef)*
      equation:("equation" _ "=" _ e:Expression)?
      _ "}"
      {
        return { type: "ConstraintDef", name, inParameters, outParameters, members, equation, location: location() };
      }

  Executable
    = "executable" _ "def" _ name:ID _ "(" _
      inParams:(
        "in" _ first:TypeUse_NoSemicolon
        rest:(_ "," _ "in" _ p:TypeUse_NoSemicolon { return p; })*
        { return [ first, ...rest ]; }
      )? _ ")" _
      ":" _ "out" _ returnType:QualifiedName _
      "{" _
        properties:( _ Property )*
        body:( _ NonBlockStatement )+
      _ "}"
      {
        return {
          type:       "Executable",
          name,
          params:     inParams||[],
          returnType,
          properties: properties.map(p => p[1]),
          body:       body.map(b => b[1]),
          location:   location()
        };
      }

  // =============================================================================
  // --- Elementos de Comportamento ---
  // =============================================================================

  ActivityBody
    = "body" _ "{" _
      // bloco actions
      actions:
        (
          _ "actions" _ ":" _
          list:ActionUse+
          { return list; }
        )?
      rels:
        (
          _ r:ActivityRelation { return r; }
        )*
      // e zero ou mais DataStore/DataBuffer
      dataObjs:
        (
          _ d:(DataStore / DataBuffer) { return d; }
        )*
      _ "}"
      {
        return {
          type:        "ActivityBody",
          actions:     actions  || [],
          relations:   rels,
          dataObjects: dataObjs,
          location:    location()
        };
      }


  PinUse
    = name:ID _ ":" _ type:QualifiedName _ ";" _
    { return { name, type, location: location() }; }

  UsingPins
    = "using" _ "pins" _ ":" _
      uses:(_ PinUse)+
      {
        return uses.map(u => u[1]);
      }

  ActionUse
    = name:ID _ ":" _ definition:QualifiedName _ (
        // forma simples
        ";" _ {
          return {
            type:       "ActionUse",
            name,
            definition,
            using:      [],
            properties: [],
            location:   location()
          };
        }
      / // forma com bloco
        "{" _ 
            up:("using" _ "pins" _ ":" _ pu:PinUse* { return pu; })?
            props:Property*
          _ "}" _
        {
          return {
            type:       "ActionUse",
            name,
            definition,
            using:      up || [],
            properties: props,
            location:   location()
          };
        }
      )


  ActivityRelation
    = ActivityDelegation
    / ActivityFlow

  ActivityDelegation
    = "delegate" _ source:QualifiedName _ "to" _ target:QualifiedName _ ";"? _
    { return { type:"ActivityDelegation", source, target, location:location() }; }

  ActivityFlow
    = "flow" _ "from" _ source:QualifiedName _ "to" _
      // agora o target pode ser um QualifiedName OU um bloco ActivitySwitch
      target:( ActivitySwitch / QualifiedName ) _
      ";"? _
      {
        return { type: "ActivityFlow", source, target, location: location() };
      }

  ActivitySwitch
    = "switch" _ "{" _ cases:ActivitySwitchCase* _ "}"
      { return { type: "ActivitySwitch", cases, location: location() }; }

  ActivitySwitchCase
    = "case" _ condition:Expression _ ":" _ target:QualifiedName _ ","? _
      {
        return { type: "ActivitySwitchCase", condition, target, location: location() };
      }


  DataObject = obj:(DataStore / DataBuffer) { return obj; }

  DataStore
    = "datastore" _ name:ID? _ ":" _ type:QualifiedName _ arrayIndex:Index? _
      (
        // primeiro, tenta o bloco
        "{" _ 
          props:Property*
          initVal:("initial" _ "value" _ "=" _ v:Expression _ ";")?
        _ "}" _
        {
          return {
            type:       "DataStore",
            name,
            dataType:   type,
            arrayIndex,
            properties: props,
            initValue:  initVal ? initVal[4] : null,
            location:   location()
          };
        }
      / // se não vier bloco, cai aqui: ponto‐e‐vírgula opcional
        ";"? _
        {
          return {
            type:       "DataStore",
            name,
            dataType:   type,
            arrayIndex,
            properties: [],
            initValue:  null,
            location:   location()
          };
        }
      )


  DataBuffer
    = "databuffer" _ name:ID? _ ":" _ type:QualifiedName _ arrayIndex:Index? _
      (
        // bloco primeiro
        "{" _
          props:Property*
          initVal:("initial" _ "value" _ "=" _ v:Expression _ ";")?
        _ "}" _
        {
          return {
            type:       "DataBuffer",
            name,
            dataType:   type,
            arrayIndex,
            properties: props,
            initValue:  initVal ? initVal[4] : null,
            location:   location()
          };
        }
      / // depois a forma simples
        ";"? _
        {
          return {
            type:       "DataBuffer",
            name,
            dataType:   type,
            arrayIndex,
            properties: [],
            initValue:  null,
            location:   location()
          };
        }
      )


  ProtocolBody
    = recControl:ProtocolControl _ body:ProtocolBodyInternal _ recursive:(recType:ProtocolAlternativeType _ r:ProtocolBody { return { recType, recursive: r }; })?
      { return { type: "ProtocolBody", recControl, body, recursive, location: location() };
      }

  ProtocolBodyInternal
    = "(" _ body:ProtocolBody _ ")" { return body; }
    / ActionSend
    / ActionReceive

  ActionSend
    = "send" _ expression:Expression _ "via" _ flowTo:QualifiedName
      { return { type: "ActionSend", expression, flowTo, location: location() };
      }

  ActionReceive
    = "receive" _ v:TypeUse _ "from" _ flowTo:QualifiedName
      { return { type: "ActionReceive", variable: v, flowTo, location: location() };
      }

  // =============================================================================
  // --- Statements (Comandos) ---
  // =============================================================================

  Statement
    = stmt:(
        ScenarioRef /
        SceneRef /
        IncDecStatement /
        Assignment /
        Invocation /
        NonBlockStatement /
        BlockStatement
      ) { return stmt; }

  IncDecStatement
    = name:QualifiedName _ op:("++" / "--") _ ";"
    { return { type:"IncDec", name, op, location: location() }; }
    
  NonBlockStatement
    = stmt:(
        AssignmentExpression _ ";" /
        VariableDecl /
        ReturnStatement /
        WhileStatement /
        DoStatement /
        ForStatement /
        IfBlockStatement /
        SwitchStatement
      ) { return stmt; }

  BlockStatement
    = "{" _
      stmts:
        (
          _ stmt:Statement  
          { return stmt; }
        )+
      _ "}"
      {
        return { type: "BlockStatement", body: stmts, location: location() };
      }


  VariableDecl
    = "let" _ name:ID _ ":" _ definition:QualifiedName _ arrayIndex:Index? _ value:("=" _ v:Expression)? _ ";"
      {
        return { type: "VariableDecl", name, definition, arrayIndex, value, location: location() };
      }

  IfBlockStatement
    = main_if:IfStatement _ else_if:("else" _ "if" _ s:IfStatement { return s; })* _ else_stmt:("else" _ s:Statement { return s; })?
      {
        return { type: "IfBlockStatement", main_if, else_if, else_stmt, location: location() };
      }

  IfStatement
    = "if" _ "(" _ condition:Expression _ ")" _ body:Statement
      {
        return { type: "IfStatement", condition, body, location: location() };
      }

  ReturnStatement
    = "return" _ value:Expression _ ";"
      { return { type: "ReturnStatement", value, location: location() }; }

  WhileStatement
    = "while" _ "(" _ condition:Expression _ ")" _ body:Statement
      { return { type: "WhileStatement", condition, body, location: location() }; }

  DoStatement
    = "do" _ body:Statement _ "while" _ "(" _ condition:Expression _ ")"
      { return { type: "DoStatement", body, condition, location: location() }; }

  ForStatement
    = "for" _ "(" _ control:ForControl _ ")" _ body:Statement
      { return { type: "ForStatement", control, body, location: location() }; }

  ForControl
    = vars:ForVarList { return { type: "ForControl", vars, location: location() }; }

  ForVar
    = v:VariableDecl _ "in" _ expr:Expression
      { return { type: "ForVar", variable: v, expression: expr, location: location() }; }

  SwitchStatement
    = "switch" _ "(" _ expr:Expression _ ")" _ "{" _ clauses:SwitchClause* _ defaultClause:DefaultSwitchClause? _ "}"
      { return { type: "SwitchStatement", expression: expr, clauses, defaultClause, location: location() }; }

  SwitchClause
    = "case" _ value:Expression _ ":" _ body:Statement
      { return { type: "SwitchClause", value, body, location: location() }; }

  DefaultSwitchClause
    = "default" _ ":" _ body:Statement
      { return { type: "DefaultSwitchClause", body, location: location() }; }

  // =============================================================================
  // --- Expressions (Expressões com Precedência de Operadores) ---
  // =============================================================================

  Expression
    = ConditionalExpression
    / AssignmentExpression

  AssignmentExpression
    = left:LeftHandSide _ op:AssignmentOperator _ right:Expression
      { return { type: "AssignmentExpression", left, operator: op, right, location: location() }; }

  ConditionalExpression
    = condition:ConditionalImpliesExpression _ "?" _ then:Expression _ ":" _ alternate:ConditionalImpliesExpression
      { return { type: "ConditionalExpression", condition, then, alternate, location: location() }; }
    / ConditionalImpliesExpression

  ConditionalImpliesExpression
    = left:ConditionalOrExpression _ tail:("implies" _ right:ConditionalOrExpression { return right; })*
      { return tail.length ? { type: "BinaryExpression", operator: "implies", left, right: tail[0], location: location() } : left; }

  ConditionalOrExpression
    = left:ConditionalAndExpression _ tail:("||" _ right:ConditionalAndExpression { return right; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: "||", left: a, right: b, location: location() }), left); }

  ConditionalAndExpression
    = left:InclusiveOrExpression _ tail:("&&" _ right:InclusiveOrExpression { return right; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: "&&", left: a, right: b, location: location() }), left); }

  InclusiveOrExpression
    = left:ExclusiveOrExpression _ tail:("|" _ right:ExclusiveOrExpression { return right; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: "|", left: a, right: b, location: location() }), left); }

  ExclusiveOrExpression
    = left:AndExpression _ tail:("^" _ right:AndExpression { return right; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: "^", left: a, right: b, location: location() }), left); }

  AndExpression
    = left:EqualityExpression _ tail:("&" _ right:EqualityExpression { return right; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: "&", left: a, right: b, location: location() }), left); }

  EqualityExpression
    = left:ClassificationExpression _ tail:(op:EqualityOperator _ right:ClassificationExpression { return { op, right }; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: b.op, left: a, right: b.right, location: location() }), left); }

  ClassificationExpression
    = op:RelationalExpression _ typeName:(_ operator:("instanceof" / "hastype") _ t:QualifiedName { return { operator, typeName: t }; })?
      { return typeName ? { type: "ClassificationExpression", operand: op, ...typeName, location: location() } : op; }

  RelationalExpression
    = left:ShiftExpression _ tail:(op:RelationalOperator _ right:ShiftExpression { return { op, right }; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: b.op, left: a, right: b.right, location: location() }), left); }

  ShiftExpression
    = left:AdditiveExpression _ tail:(op:ShiftOperator _ right:AdditiveExpression { return { op, right }; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: b.op, left: a, right: b.right, location: location() }), left); }

  AdditiveExpression
    = left:MultiplicativeExpression _ tail:(op:AdditiveOperator _ right:MultiplicativeExpression { return { op, right }; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: b.op, left: a, right: b.right, location: location() }), left); }

  MultiplicativeExpression
    = left:UnaryExpression _ tail:(op:MultiplicativeOperator _ right:UnaryExpression { return { op, right }; })*
      { return tail.reduce((a, b) => ({ type: "BinaryExpression", operator: b.op, left: a, right: b.right, location: location() }), left); }

  UnaryExpression
    = op:("!" / "~" / "$") _ operand:UnaryExpression
      { return { type: "UnaryExpression", operator: op, operand, location: location() }; }
    / IncrementOrDecrementExpression

  IncrementOrDecrementExpression
    = operand:LeftHandSide op:AffixOperator { return { type: "PostfixExpression", operand, operator: op, location: location() }; }
    / op:AffixOperator operand:LeftHandSide { return { type: "PrefixExpression", operator: op, operand, location: location() }; }
    / PrimaryExpression

  //PrimaryExpression
  //  = DataTypeAccessExpression           // foo->bar
  //  / EnumValueLiteralExpression         // foo::BAR
  //  / InstanceCreationExpression         // new Foo()
  //  / SequenceConstructionExpression     // {…}
  //  / SequenceAccessExpression           // foo[…]
  //  / NameExpression                     // simples QualifiedName
  //  / LiteralExpression                  // números, strings, true/false, null
  //  / ThisExpression                     // this
  //  / ParenthesizedExpression            // ( … )

  // tenta primeiro acesso a tipo com '->'
  PrimaryExpression
    = DataTypeAccessExpression
    // literal de enum com '::'
    / EnumValueLiteralExpression
    // cria novos objetos
    / InstanceCreationExpression
  // literais de array com colchetes: [ a, b, c ]
  / ArrayLiteralExpression
    // constrói sequências inline
    / SequenceConstructionExpression
    // acessa sequência
    / SequenceAccessExpression
    // nomes simples (QualifiedName)
    / NameExpression
    // literais (string, número, booleano, null)
    / LiteralExpression
    // 'this'
    / ThisExpression
    // parênteses
    / ParenthesizedExpression


  NonNameExpression
    = LiteralExpression
    / ThisExpression
    / ParenthesizedExpression
    / DataTypeAccessExpression
    / InstanceCreationExpression
    / SequenceConstructionExpression
    / SequenceAccessExpression

  NameExpression
    = name:QualifiedName { return { type: "NameExpression", name, location: location() }; }

  InstanceCreationExpression
    = "new" _ typeName:QualifiedName _ index:Index?
      { return { type: "InstanceCreationExpression", typeName, index, location: location() }; }

  SequenceConstructionExpression
    = "{" _ elements:SequenceElements? _ "}"
      { return { type: "SequenceConstructionExpression", elements, location: location() }; }

  // Array literal usando colchetes, ex: [ stationA, stationB ]
  ArrayLiteralExpression
    = "[" _ elements:QualifiedNameList? _ "]"
      { return { type: "ArrayLiteralExpression", elements: elements ? elements.items : [], location: location() }; }

  SequenceElements
    = elements:(SequenceExpressionList / SequenceRange) { return elements; }

  SequenceExpressionList
    = head:LiteralExpression tail:(_ "," _ e:LiteralExpression { return e; })* _ ","?
      { return { type: "SequenceExpressionList", elements: [head, ...tail], location: location() }; }

  SequenceRange
    = lower:NaturalLiteralExpression _ ".." _ upper:NaturalLiteralExpression
      { return { type: "SequenceRange", lower, upper, location: location() }; }

  SequenceAccessExpression
    = primary:NameExpression _ index:NonEmptyIndex
      { return { type: "SequenceAccessExpression", primary, index, location: location() }; }

  DataTypeAccessExpression
    = datatype:QualifiedName _ "->" _ attr:ID _ index:NonEmptyIndex?
      { return { type: "DataTypeAccessExpression", datatype, attr, index, location: location() }; }

  LiteralExpression
    = BooleanLiteralExpression
    / NaturalLiteralExpression
    / StringLiteralExpression
    / EnumValueLiteralExpression
    / NullLiteralExpression

  NullLiteralExpression
    = "null" { return { type: "NullLiteral", value: null, location: location() }; }

  EnumValueLiteralExpression
    = enumName:QualifiedName _ "::" _ value:ID
      { return { type: "EnumValueLiteral", enumName, value, location: location() }; }

  BooleanLiteralExpression
    = value:EBoolean { return { type: "BooleanLiteral", value, location: location() }; }

  NaturalLiteralExpression
    = value:INT { return { type: "NaturalLiteral", value: parseInt(value, 10), location: location() }; }

  StringLiteralExpression
    = value:STRING { return { type: "StringLiteral", value, location: location() }; }

  ThisExpression
    = "this" { return { type: "ThisExpression", location: location() }; }

  ParenthesizedExpression
    = "(" _ expr:Expression _ ")" { return expr; }

  LeftHandSide
    = feature:DataTypeAccessExpression {
        return feature;
      }
    / feature:EnumValueLiteralExpression {
        return feature;
      }
    / target:NameExpression index:NonEmptyIndex? {
        return { type: "LeftHandSide", target, index, location: location() };
      }
    / "(" _ lhs:LeftHandSide _ ")" {
        return lhs;
      }


  // =============================================================================
  // --- Operadores ---
  // =============================================================================

  AssignmentOperator = op:("=" / "+=" / "-=" / "*=" / "%=" / "/=" / "&=" / "|=" / "^=" / "<<=" / ">>=" / ">>>=") { return op; }
  EqualityOperator = op:("==" / "!=") { return op; }
  RelationalOperator = op:("<=" / ">=" / "<" / ">") { return op; }
  ShiftOperator = op:("<<" / ">>>" / ">>") { return op; }
  AdditiveOperator = op:("+" / "-") { return op; }
  MultiplicativeOperator = op:("*" / "/" / "%") { return op; }
  AffixOperator = op:("++" / "--") { return op; }

  // =============================================================================
  // --- Elementos Básicos e Terminais ---
  // =============================================================================

  Property
    = "property" _ name:ID _ type:(":" _ t:QualifiedName)? _ value:("=" _ v:Expression)? _ ";"
      {
        return { type: "Property", name, propertyType: type, value, location: location() };
      }

  Pin
    = name:ID _ ":" _ isFlow:("flow" _)? definition:QualifiedName _ arrayIndex:Index?
      {
        return { type: "Pin", name, isFlow: !!isFlow, definition, arrayIndex, location: location() };
      }

  TypeUse
    = name:ID _ ":" _ definition:QualifiedName _ arrayIndex:Index? _
      body:("{" _ properties:Property* _ "}" / ";")
      {
        return { type: "TypeUse", name, definition, arrayIndex, body, location: location() };
      }

  TypeUse_NoSemicolon
    = name:ID _ ":" _ definition:QualifiedName _ arrayIndex:Index? _
      body:("{" _ properties:Property* _ "}")?
      {
        return { type: "TypeUse", name, definition, arrayIndex, body, location: location() };
      }

  Index
    = ("[" _ expr:Expression? _ "]")+

  NonEmptyIndex
    = ("[" _ expr:Expression _ "]")+

  FlowProperty
    = prop:("in" / "out" / "inout") { return prop; }

  ProtocolAlternativeType
    = type:(";" / "|") { return type; }

  ProtocolControl
    = control:("always" / "several" / "once" / "perhaps") { return control; }

  AllocationTable
    = "allocations" _ "{" _
      allocs:
        (
          _ a:(ExecutableAllocation / ActivityAllocation)
        )*
      _ "}"
      {
        return {
          type:        "AllocationTable",
          allocations: allocs.map(a => a[1]),
          location:    location()
        };
      }

  Allocation
    = alloc:(ExecutableAllocation / ActivityAllocation) { return alloc; }

  ExecutableAllocation
    = "executable" _ source:(QualifiedName / "null") _ "to" _ target:(QualifiedName / "null")
      { return { type: "ExecutableAllocation", source, target, location: location() }; }

  ActivityAllocation
    = "activity" _ source:(QualifiedName / "null") _ "to" _ target:(QualifiedName / "null")
      { return { type: "ActivityAllocation", source, target, location: location() }; }

  Bounds
    = "[" _ lower:EInt _ "," _ upper:EInt _ "]" { return { lower, upper }; }

  // =============================================================================
  // --- NOVOS ELEMENTOS: ENVIRONMENT AND SCENARIO VIEWPOINTS ---
  // =============================================================================

  EnvironmentDefinition
    = "EnvironmentDefinition" _ name:ID _ "{" _
      entities:
        (
          _ e:EntityDef { return e; }
        )*
      // zero ou mais ConnectionDef, idem
      connections:
        (
          _ c:ConnectionDef { return c; }
        )*
    _ "}"
    {
      return {
        type:         "EnvironmentDefinition",
        name,
        entities,
        connections,
        location:     location()
      };
    }

  EntityUse
    =
      // forma com identificador: id: Type[]  ou id: 1|n
      id:ID _ ":" _ (
        // forma com tipo explícito: stations: Station[]
        type:QualifiedName _ arrayIndex:Index? {
          return { name: id, type, arrayIndex, location: location() };
        }
      / // forma abreviada com cardinalidade: stations: n  ou stations: 1
        card:("1" / "n") {
          return { name: id, cardinality: card, location: location() };
        }
      )
    / // forma sem identificador, apenas o tipo (ex: Station[])
      typeOnly:QualifiedName _ arrayIndex:Index? {
        return { name: typeOnly, type: typeOnly, arrayIndex, location: location() };
      }

  EntityUseList
    = head:EntityUse tail:(_ "," _ e:EntityUse { return e; })*
      { return { type: "EntityUseList", items: [head, ...tail], location: location() }; }


  EntityDef
    = "Entity" _ "def" _ name:ID _ "{" _
    items:
      (
        // pula whitespace antes de cada bloco
        _ stmt:
          (
            // bloco de sub-entidades, agora permitindo Station[] etc.
            "entities" _ "{" _ c:EntityUseList _ "}"
              {
                return { kind: "compositions", value: c };
              }
          / // bloco de propriedades
            "properties" _ "{" _
              ps:( _ PropertyDef )*
            _ "}"
              {
                return { kind: "propertyDefs", value: ps.map(p => p[1]) };
              }
          / // bloco de papéis
            "roles" _ "{" _
              rs:( _ RoleDef )*
            _ "}"
              {
                return { kind: "roles", value: rs.map(r => r[1]) };
              }
          )
        { return stmt; }
      )*
    _ "}"
    {
      // consolida todos os itens por tipo
      let compositions = [], propertyDefs = [], roles = [];
      for (const it of items) {
        if (it.kind === "compositions")  compositions  = it.value;
        if (it.kind === "propertyDefs")  propertyDefs  = it.value;
        if (it.kind === "roles")         roles         = it.value;
      }
      return {
        type:         "EntityDef",
        name,
        compositions,
        propertyDefs,
        roles,
        location:     location()
      };
    }

  PropertyDef
      = "Property" _ "def" _ name:ID
      { return { type: "PropertyDef", name, location: location() }; }

  RoleDef
      = "Role" _ type:("def" / "in" / "out") _ name:ID
      { return { type: "RoleDef", roleType: type, name, location: location() }; }

  ConnectionDef
   = "Connection" _ "def" _ name:ID _ "{" _
     _ "from" _ fromEntity:ID _ "." _ fromRole:ID _
     _ "to"   _ toEntity:ID   _ "." _ toRole:ID   _
   _ "}"
   {
     return {
       type: "ConnectionDef",
       name,
       from: { entity: fromEntity, port: fromRole },
       to:   { entity: toEntity,   port: toRole   },
       location: location()
     };
   }

  EnvironmentConfiguration
    = "EnvironmentConfiguration" _ name:ID _ "to" _ definition:QualifiedName _
    "{" _
    mappings:
        (
          _ m:(Instantiation / Association / Assignment)
            { return m; }
        )*
    _ "}"
    { return { type: "EnvironmentConfiguration", name, definition, mappings, location: location() }; }

  Instantiation
    = instance:ID _ ":" _ entityType:QualifiedName _ ";" _
      {
        return { type: "Instantiation", instance, entityType, location: location() };
      }

  Association
    = source:QualifiedName _ ":" _ target:QualifiedName _ ";" _
      {
        return { type: "Association", source, target, location: location() };
      }

  EventsDefinitions
    = "EventsDefinitions" _ name:ID _ "to" _ config:QualifiedName _
      "{" _
        eventDefs:( _ EventDef )+
      _ "}"
      {
        return { type: "EventsDefinitions", name, config, eventDefs: eventDefs.map(e => e[1]), location: location() };
      }


  EventDef
    = "Event" _ "def" _ name:ID _ "for" _ target:QualifiedName _
      "{" _
        triggers:( _ TriggerBlock )+
      _ "}"
      {
        return { type: "EventDef", name, target, triggers: triggers.map(t => t[1]), location: location() };
      }


  TriggerBlock
    = "ON" _ condition:ConditionBlock
        actions:(
          _ "THEN" _ a:ActionBlock { return a; }
        )+
      {
        return { type: "TriggerBlock", condition, actions, location: location() };
      }

  ConditionBlock
      = condName:QualifiedName _ value:("==" _ v:QualifiedName { return v; })?
      { return { type: "ConditionBlock", name: condName, value, location: location() }; }

  ConditionStmt
      = _ cond:ConditionBlock _ ";"?
      { 
        return { ...cond, location: location() }; 
      }

  ActionBlock
    = name:ID _ "{" _
      stmts:
        (
          _ stmt:(Assignment / Invocation)
          { return stmt; }
        )*
      _ "}"
      {
        return { type: "ActionBlock", name, statements: stmts, location: location() };
      }


  Assignment
      = left:QualifiedName _ "=" _ right:Expression _ ";"
      { return { type: "Assignment", left, right, location: location() }; }

  Invocation
      = ":" _ ref:QualifiedName _ "(" _ args:QualifiedNameList? _ ")" _ ";"
      { return { type: "Invocation", connection: ref, args: args || [], location: location() }; }

  SceneDefinitions
    = "SceneDefinitions" _ name:ID _ "to" _ events:QualifiedName _
      "{" _
        scenes:( _ s:SceneDef { return s; } )*
      _ "}"
      {
        return { type: "SceneDefinitions", name, events, scenes, location: location() };
      }

  SceneDef
      = "Scene" _ "def" _ name:ID _ "on" _ "{" _
          _ "pre-condition" _ "{" _ preconds:ConditionStmt* _ "}" _
          _ "start" _ start:QualifiedName _ ";"? _
          _ "finish" _ finish:QualifiedName _ ";"? _
          _ "post-condition" _ "{" _ postconds:ConditionStmt* _ "}" _
      _ "}"
      { return { type: "SceneDef", name, preconds, start, finish, postconds, location: location() }; }

  ScenarioDefinitions
    = "ScenarioDefinitions" _ name:ID _ "to" _ scenes:QualifiedName _
      "{" _
        scenarios:( _ s:ScenarioDef { return s; } )*
      _ "}"
      {
        return { type: "ScenarioDefinitions", name, scenes, scenarios, location: location() };
      }

  ScenarioDef
      = "Scenario" _ "def" _ name:ID _ "{" _
          items:( _ it:(Statement / SceneRef) { return it; } )*
        _ "}"
      { return { type: "ScenarioDef", name, body: items, location: location() }; }

  ScenarioBody
      = body:(SceneRef / LoopBlock / VarDecl) { return body; }

  SceneRef
      = ref:QualifiedName _ ";"
      { return { type: "SceneRef", ref, location: location() }; }

  LoopBlock
      = "var" _ varName:ID _ "=" _ start:INT _
      "while" _ condVar:ID _ "<" _ limit:INT _ "{" _ body:ScenarioBody* _ "}"
      { return { type: "LoopBlock", varName, start, condVar, limit, body, location: location() }; }

  VarDecl
      = "var" _ varName:ID _ "=" _ value:INT _ ";"?
      { return { type: "VarDecl", varName, value, location: location() }; }

  WhileBlock
      = "while" _ condVar:ID _ "<" _ limit:INT _ "{" _ body:ScenarioBody* _ "}"
      { return { type: "WhileBlock", condVar, limit, body, location: location() }; }

  IncStmt
      = varName:ID _ "++" _ ";"
      { return { type: "IncStmt", varName, location: location() }; }

  ScenarioRef
    = name:QualifiedName _ ";" _
      { return { type: "ScenarioRef", name, location: location() }; }

  ScenarioExecution
    = "ScenarioExecution" _ "to" _ defs:QualifiedName _ "{" _
        items:( _ it:(Assignment / SceneRef / ExecutionEntry / EventInjection / EventInjectionBatch) { return it; } )*
      _ "}"
      {
        return { type: "ScenarioExecution", defs, items, location: location() };
      }

  EventInjection
    = "inject" _ eventName:QualifiedName _ timing:EventTiming? _ ";"
      { return { type: "EventInjection", eventName, timing, location: location() }; }

  EventInjectionBatch
    = "inject_batch" _ "[" _ events:EventNameList _ "]" _ mode:("parallel" / "sequential")? _ ";"
      { return { type: "EventInjectionBatch", events, mode: mode || "sequential", location: location() }; }

  EventNameList
    = head:QualifiedName tail:(_ "," _ e:QualifiedName { return e; })*
      { return [head, ...tail]; }

  EventTiming
    = "after" _ delay:INT _ unit:("ms" / "s")
      { return { type: "delay", value: unit === "s" ? delay * 1000 : delay }; }
    / "when" _ condition:BooleanExpression
      { return { type: "condition", expression: condition }; }
    / "before" _ scenario:QualifiedName
      { return { type: "before", scenario }; }
    / "after" _ scenario:QualifiedName
      { return { type: "after", scenario }; }

  BooleanExpression
    = left:ID _ operator:(">" / "<" / ">=" / "<=" / "==" / "!=") _ right:(ID / INT)
      { return { type: "BinaryExpression", left, operator, right, location: location() }; }

  ExecutionEntry
      = repeat:("repeat" _ t:INT { return t; })? _ scenario:QualifiedName _ ";"
      { return { type: "ExecutionEntry", repeat: repeat || 1, scenario, location: location() }; }

  // =============================================================================
  // --- Listas Auxiliares ---
  // =============================================================================

  QualifiedNameList
    = head:QualifiedName tail:(_ "," _ q:QualifiedName { return q; })*
      { return { type: "QualifiedNameList", items: [head, ...tail], location: location() }; }

  PinList
    = head:Pin tail:(_ "," _ p:Pin { return p; })*
      { return [ head, ...tail ]; }

  AbstractPinList
    = head:AbstractPin tail:(_ "," _ p:AbstractPin { return p; })*
      { return [ head, ...tail ]; }

  EnumLiteralValueList
    = head:EnumLiteralValue tail:(_ "," _ v:EnumLiteralValue { return v; })*
      { return { type: "EnumLiteralValueList", items: [head, ...tail], location: location() }; }

  ConnectorBindingList
    = head:ConnectorBinding tail:(_ "," _ b:ConnectorBinding { return b; })*
      { return { type: "ConnectorBindingList", items: [head, ...tail], location: location() }; }

  ForVarList
    = head:ForVar tail:(_ "," _ v:ForVar { return v; })*
      { return { type: "ForVarList", items: [head, ...tail], location: location() }; }

  // =============================================================================
  // --- Nomes e Terminais ---
  // =============================================================================

  QualifiedName
    = head:ID tail:("." p:ID { return p; })*
      { return [head, ...tail].join('.'); }

  EString
    = STRING
    / ID

  // Terminais (Definições de baixo nível)
  ID "Identifier"
    = [a-zA-Z_] [a-zA-Z0-9_]* { return text(); }

  INT "Integer"
    = [0-9]+ { return text(); }

  EInt "Integer with sign"
    = sign:"-"? value:INT { return parseInt( (sign || "") + value, 10); }

  STRING "String"
    = '"' chars:( '\\' . / [^"\\] )* '"' {
        return chars.join('').replace(/\\(.)/g,'$1');
      }
    / "'" chars:( '\\' . / [^'\\] )* "'" {
        return chars.join('').replace(/\\(.)/g,'$1');
      }

  EBoolean "Boolean"
    = v:("true" / "false") { return v === "true"; }

  EFloat "Float"
    = sign:"-"? intPart:INT? "." fracPart:INT expPart:(("E" / "e") expSign:"-"? exp:INT)?
      { return parseFloat(text()); }

  _ "Whitespace"
    = ([ \t\n\r] / SingleLineComment / MultiLineComment)*

  SingleLineComment
    = "//" [^\n\r]*

  MultiLineComment
    = "/*" (!"*/" .)* "*/"
