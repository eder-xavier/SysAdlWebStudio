// Environment and Scenario Module for AGV-completo
// Auto-generated by SysADL Transformer
const { EnvironmentDefinition, EnvironmentConfiguration, Entity, Event, Scene, Scenario, ScenarioExecution, EventsDefinitions, SceneDefinitions, ScenarioDefinitions, Connection } = require('../SysADLBase');
const { createModel } = require('./AGV-completo');

// Entity: Station
class Station extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Station',
      properties: {},
      roles: ["signal"]
    });
    
  }
}

// Entity: PartX
class PartX extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'PartX',
      properties: {},
      roles: ["surface"]
    });
    
  }
}

// Entity: Lane
class Lane extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Lane',
      properties: {},
      roles: []
    });
    
    // Composition structure
    this.entities = {};
    this.entities.stations = []; // Array of Station
    this.entities.vehicles = []; // Array of Vehicle
    this.entities.partx = null; // PartX
    
  }
}

// Entity: Supervisory
class Supervisory extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Supervisory',
      properties: {},
      roles: ["inNotification","outCommand"]
    });
    
  }
}

// Entity: Vehicle
class Vehicle extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Vehicle',
      properties: {},
      roles: ["outNotification","inCommand","sensor","arm"]
    });
    
  }
}

// Connection: Notify
class Notify extends Connection {
  constructor(name = 'Notify', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.outNotification',
      to: 'Supervisory.inNotification'
    });
  }
}

// Connection: Command
class Command extends Connection {
  constructor(name = 'Command', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Supervisory.outCommand',
      to: 'Vehicle.inCommand'
    });
  }
}

// Connection: Location
class Location extends Connection {
  constructor(name = 'Location', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Station.signal',
      to: 'Vehicle.sensor'
    });
  }
}

// Connection: Atach
class Atach extends Connection {
  constructor(name = 'Atach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Connection: Detach
class Detach extends Connection {
  constructor(name = 'Detach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Environment Definition: MyFactory
class MyFactory extends EnvironmentDefinition {
  constructor() {
    super();
    
    // Available entity types (classes)
    this.entities = [Station, PartX, Lane, Supervisory, Vehicle];
    
    // Available connection types
    this.connections = [Notify, Command, Location, Atach, Detach];
  }
  
  createEntity(typeName, options = {}) {
    // Validation: check if typeName is declared in entities array
    const EntityClass = this.entities.find(cls => cls.name === typeName);
    if (!EntityClass) {
      throw new Error(`Entity type '${typeName}' is not declared in this environment definition. Available types: ${this.entities.map(cls => cls.name).join(', ')}`);
    }
    
    // Create instance with unique name if not provided
    const instanceName = options.name || `${typeName.toLowerCase()}_${Date.now()}`;
    const instance = new EntityClass(instanceName, options);
    
    // Set properties if provided
    if (options.properties) {
      Object.assign(instance.properties, options.properties);
    }
    
    return instance;
  }
}

// Environment Configuration: MyFactoryConfiguration
class MyFactoryConfiguration extends EnvironmentConfiguration {
  constructor() {
    super(new MyFactory());
    
    // Associations (role bindings)
    this.associations = {
      "Vehicle.outNotification": "agvs.in_outDataAgv.outNotifications",
      "Vehicle.inCommand": "agvs.in_outDataAgv.inMoveToStation",
      "Vehicle.sensor": "agvs.as.arrivalDetected",
      "Vehicle.arm": "agvs.ra.start",
      "Supervisory.inNotification": "ss.in_outDataS.inNotifications",
      "Supervisory.outCommand": "ss.in_outDataS.outMoveToStation"
    };
    
    // Entity instances
    this.Vehicle = this.createEntity('agvs');
    this.Supervisory = this.createEntity('ss');
    this.agv1 = this.createEntity('Vehicle');
    this.agv2 = this.createEntity('Vehicle');
    this.stationA = this.createEntity('Station', { properties: {"ID":"StationA"} });
    this.stationB = this.createEntity('Station', { properties: {"ID":"StationB"} });
    this.stationC = this.createEntity('Station', { properties: {"ID":"StationC"} });
    this.stationD = this.createEntity('Station', { properties: {"ID":"StationD"} });
    this.stationE = this.createEntity('Station', { properties: {"ID":"StationE"} });
    this.supervisor = this.createEntity('Supervisory');
    this.part = this.createEntity('PartX');
    this.lane1 = this.createEntity('Lane');
    this.lane2 = this.createEntity('Lane');
    
    // Compositions
    this.lane1.entities.stations = [this.stationA, this.stationB, this.stationC];
    this.lane2.entities.stations = [this.stationC, this.stationD, this.stationE];
  }
}

// Events Definitions: MyEvents
class MyEvents extends EventsDefinitions {
  constructor(name = 'MyEvents', opts = {}) {
    super(name, {
      ...opts,
      targetConfiguration: 'MyFactoryConfiguration',
      events: {}
    });
  }
}

// Scene Definitions: MyScenes
class MyScenes extends SceneDefinitions {
  constructor(name = 'MyScenes', opts = {}) {
    super(name, {
      ...opts,
      targetEvents: 'MyEvents',
      scenes: {}
    });
  }
}

// Scenario Definitions: MyScenarios
class MyScenarios extends ScenarioDefinitions {
  constructor(name = 'MyScenarios', opts = {}) {
    super(name, {
      ...opts,
      targetScenes: 'MyScenes',
      scenarios: {}
    });
  }
}

// Scenario Execution: MyScenariosExecution
class MyScenariosExecution extends ScenarioExecution {
  constructor(name = 'MyScenariosExecution', opts = {}) {
    super(name, {
      ...opts,
      targetScenarios: 'MyScenarios',
      scenarios: [],
      executionMode: 'sequential'
    });
  }
}

function createEnvironmentModel() {
  const model = createModel(); // Get traditional model
  
  // Initialize scenario execution capabilities
  model.initializeScenarioExecution();
  
  // Add environment/scenario elements to model
  model.environments = {};
  model.events = {};
  model.scenes = {};
  model.scenarios = {};
  model.scenarioExecutions = {};
  
  model.environments['MyFactory'] = new MyFactory();
  model.environments['MyFactoryConfiguration'] = new MyFactoryConfiguration();
  model.events['MyEvents'] = new MyEvents();
  model.scenes['MyScenes'] = new MyScenes();
  model.scenarios['MyScenarios'] = new MyScenarios();
  model.scenarioExecutions['MyScenariosExecution'] = new MyScenariosExecution();
  model.registerScenarioExecution(model.scenarioExecutions['MyScenariosExecution']);
  
  // Setup environment bindings if needed
  // TODO: Implement automatic binding setup based on model analysis
  
  return model;
}

module.exports = { createEnvironmentModel, MyFactory, MyFactoryConfiguration, MyEvents, MyScenes, MyScenarios, MyScenariosExecution };