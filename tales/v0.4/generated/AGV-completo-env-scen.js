// Environment and Scenario Module for AGV-completo
// Auto-generated by SysADL Transformer
const { EnvironmentDefinition, EnvironmentConfiguration, Entity, Event, Scene, Scenario, ScenarioExecution, EventsDefinitions, SceneDefinitions, ScenarioDefinitions, Connection } = require('../sysadl-framework/SysADLBase');
const { createModel } = require('./AGV-completo');

// Entity: Station
class Station extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Station',
      properties: {},
      roles: ["signal"]
    });
    
  }
}

// Entity: PartX
class PartX extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'PartX',
      properties: {},
      roles: ["surface"]
    });
    
  }
}

// Entity: Lane
class Lane extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Lane',
      properties: {},
      roles: []
    });
    
    // Composition structure
    this.entities = {};
    this.entities.stations = []; // Array of Station
    this.entities.vehicles = []; // Array of Vehicle
    this.entities.partx = null; // PartX
    
  }
}

// Entity: Supervisory
class Supervisory extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Supervisory',
      properties: {},
      roles: ["inNotification","outCommand"]
    });
    
  }
}

// Entity: Vehicle
class Vehicle extends Entity {
  constructor(name, opts = {}) {
    super(name, {
      ...opts,
      entityType: 'Vehicle',
      properties: {},
      roles: ["outNotification","inCommand","sensor","arm"]
    });
    
  }
}

// Connection: Notify
class Notify extends Connection {
  constructor(name = 'Notify', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.outNotification',
      to: 'Supervisory.inNotification'
    });
  }
}

// Connection: Command
class Command extends Connection {
  constructor(name = 'Command', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Supervisory.outCommand',
      to: 'Vehicle.inCommand'
    });
  }
}

// Connection: Location
class Location extends Connection {
  constructor(name = 'Location', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Station.signal',
      to: 'Vehicle.sensor'
    });
  }
}

// Connection: Atach
class Atach extends Connection {
  constructor(name = 'Atach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Connection: Detach
class Detach extends Connection {
  constructor(name = 'Detach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Environment Definition: MyFactory
class MyFactory extends EnvironmentDefinition {
  constructor() {
    super();
    
    // Available entity types (classes)
    this.entities = [Station, PartX, Lane, Supervisory, Vehicle];
    
    // Available connection types
    this.connections = [Notify, Command, Location, Atach, Detach];
  }
  
  createEntity(typeName, options = {}) {
    // Validation: check if typeName is declared in entities array
    const EntityClass = this.entities.find(cls => cls.name === typeName);
    if (!EntityClass) {
      throw new Error(`Entity type '${typeName}' is not declared in this environment definition. Available types: ${this.entities.map(cls => cls.name).join(', ')}`);
    }
    
    // Create instance with unique name if not provided
    const instanceName = options.name || `${typeName.toLowerCase()}_${Date.now()}`;
    const instance = new EntityClass(instanceName, options);
    
    // Set properties if provided
    if (options.properties) {
      Object.assign(instance.properties, options.properties);
    }
    
    return instance;
  }
}

// Environment Configuration: MyFactoryConfiguration
class MyFactoryConfiguration extends EnvironmentConfiguration {
  constructor() {
    super(new MyFactory());
    
    // Associations (role bindings)
    this.associations = {
      "Vehicle.outNotification": "agvs.in_outDataAgv.outNotifications",
      "Vehicle.inCommand": "agvs.in_outDataAgv.inMoveToStation",
      "Vehicle.sensor": "agvs.as.arrivalDetected",
      "Vehicle.arm": "agvs.ra.start",
      "Supervisory.inNotification": "ss.in_outDataS.inNotifications",
      "Supervisory.outCommand": "ss.in_outDataS.outMoveToStation"
    };
    
    // Entity instances
    this.agv1 = this.createEntity('Vehicle');
    this.agv2 = this.createEntity('Vehicle');
    this.stationA = this.createEntity('Station', { properties: {"ID":"StationA"} });
    this.stationB = this.createEntity('Station', { properties: {"ID":"StationB"} });
    this.stationC = this.createEntity('Station', { properties: {"ID":"StationC"} });
    this.stationD = this.createEntity('Station', { properties: {"ID":"StationD"} });
    this.stationE = this.createEntity('Station', { properties: {"ID":"StationE"} });
    this.supervisor = this.createEntity('Supervisory');
    this.part = this.createEntity('PartX');
    this.lane1 = this.createEntity('Lane');
    this.lane2 = this.createEntity('Lane');
    
    // Compositions
    this.lane1.entities.stations = [this.stationA, this.stationB, this.stationC];
    this.lane2.entities.stations = [this.stationC, this.stationD, this.stationE];
  }

  createEntity(typeName, options = {}) {
    // Map to environment definition entities
    const EntityMap = {
      'Station': Station,
      'PartX': PartX,
      'Lane': Lane,
      'Supervisory': Supervisory,
      'Vehicle': Vehicle
    };
    
    const EntityClass = EntityMap[typeName];
    if (!EntityClass) {
      throw new Error(`Entity type '${typeName}' is not available. Available types: ${Object.keys(EntityMap).join(', ')}`);
    }
    
    return new EntityClass(options);
  }
}

// Events Definitions: MyEvents
class MyEvents extends EventsDefinitions {
  constructor(name = 'MyEvents', opts = {}) {
    super(name, {
      ...opts,
      targetConfiguration: 'MyFactoryConfiguration'
    });

    // SupervisoryEvents Event Definition
    this.SupervisoryEvents = {
      name: 'SupervisoryEvents',
      type: 'rule-based',
      target: 'supervisor',
      rules: [
        {
          trigger: 'cmdSupervisor',
          actions: [
            { name: 'cmdAGV2toC', body: ['supervisor.outCommand.destination = \'stationC\';', 'supervisor.outCommand.armCommand = \'idle\';', '// Connection invocation: Command(supervisor, agv2)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv2\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv2\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
            { name: 'cmdAGV1toA', body: ['supervisor.outCommand.destination = \'stationA\';', 'supervisor.outCommand.armCommand = \'idle\';', '// Connection invocation: Command(supervisor, agv1)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv1\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv1\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: cmdSupervisor -> cmdAGV2toC, cmdAGV1toA');
            // Custom logic for cmdSupervisor trigger
            const results = [];
            results.push(this.executecmdAGV2toC(context));
            results.push(this.executecmdAGV1toA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifLoad',
          actions: [
            { name: 'cmdAGV1toC', body: ['supervisor.outCommand.destination = \'stationA\';', 'supervisor.outCommand.armCommand = \'idle\';', '// Connection invocation: Command(supervisor, agv1)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv1\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv1\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV1NotifLoad -> cmdAGV1toC');
            // Custom logic for AGV1NotifLoad trigger
            const results = [];
            results.push(this.executecmdAGV1toC(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveA',
          actions: [
            { name: 'cmdAGV1loadA', body: ['supervisor.outCommand.destination = \'stationA\';', 'supervisor.outCommand.armCommand = \'load\';', '// Connection invocation: Command(supervisor, agv1)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv1\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv1\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV1NotifArriveA -> cmdAGV1loadA');
            // Custom logic for AGV1NotifArriveA trigger
            const results = [];
            results.push(this.executecmdAGV1loadA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveC',
          actions: [
            { name: 'cmdAGV1UnloadA', body: ['supervisor.outCommand.destination = \'stationA\';', 'supervisor.outCommand.armCommand = \'unload\';', '// Connection invocation: Command(supervisor, agv1)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv1\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv1\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV1NotifArriveC -> cmdAGV1UnloadA');
            // Custom logic for AGV1NotifArriveC trigger
            const results = [];
            results.push(this.executecmdAGV1UnloadA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveAUnoaded',
          actions: [
            { name: 'cmdAGV2loadC', body: ['supervisor.outCommand.destination = \'stationC\';', 'supervisor.outCommand.armCommand = \'load\';', '// Connection invocation: Command(supervisor, agv2)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv2\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv2\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV1NotifArriveAUnoaded -> cmdAGV2loadC');
            // Custom logic for AGV1NotifArriveAUnoaded trigger
            const results = [];
            results.push(this.executecmdAGV2loadC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2NotifLoad',
          actions: [
            { name: 'cmdAGV2toE', body: ['supervisor.outCommand.destination = \'stationE\';', 'supervisor.outCommand.armCommand = \'idle\';', '// Connection invocation: Command(supervisor, agv2)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv2\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv2\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV2NotifLoad -> cmdAGV2toE');
            // Custom logic for AGV2NotifLoad trigger
            const results = [];
            results.push(this.executecmdAGV2toE(context));
            return results;
          }
        },
        {
          trigger: 'AGV2NotifArriveE',
          actions: [
            { name: 'cmdAGV2UnloadE', body: ['supervisor.outCommand.destination = \'stationE\';', 'supervisor.outCommand.armCommand = \'unload\';', '// Connection invocation: Command(supervisor, agv2)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Command\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Command:\', [\'supervisor\', \'agv2\']);', '    // Execute message passing between entities', '    const fromEntityName = \'supervisor\';', '    const toEntityName = \'agv2\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Command: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Command not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing SupervisoryEvents: AGV2NotifArriveE -> cmdAGV2UnloadE');
            // Custom logic for AGV2NotifArriveE trigger
            const results = [];
            results.push(this.executecmdAGV2UnloadE(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.SupervisoryEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.SupervisoryEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // AGV1Events Event Definition
    this.AGV1Events = {
      name: 'AGV1Events',
      type: 'rule-based',
      target: 'agv1',
      rules: [
        {
          trigger: 'cmdAGV1toA',
          actions: [
            { name: 'AGV1NotifTravelA', body: ['agv1.outNotification.notification = "traveling";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: cmdAGV1toA -> AGV1NotifTravelA');
            // Custom logic for cmdAGV1toA trigger
            const results = [];
            results.push(this.executeAGV1NotifTravelA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationB',
          actions: [
            { name: 'AGV1NotifPassB', body: ['agv1.outNotification.notification = "passed";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: AGV1locationStationB -> AGV1NotifPassB');
            // Custom logic for AGV1locationStationB trigger
            const results = [];
            results.push(this.executeAGV1NotifPassB(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationC',
          actions: [
            { name: 'AGV1NotifArriveC', body: ['agv1.outNotification.notification = "arrived";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: AGV1locationStationC -> AGV1NotifArriveC');
            // Custom logic for AGV1locationStationC trigger
            const results = [];
            results.push(this.executeAGV1NotifArriveC(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationA',
          actions: [
            { name: 'AGV1NotifArriveA', body: ['agv1.outNotification.notification = "arrived";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: AGV1locationStationA -> AGV1NotifArriveA');
            // Custom logic for AGV1locationStationA trigger
            const results = [];
            results.push(this.executeAGV1NotifArriveA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1atachPartX',
          actions: [
            { name: 'AGV1NotifLoad', body: ['agv1.outNotification.notification = "loaded";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: AGV1atachPartX -> AGV1NotifLoad');
            // Custom logic for AGV1atachPartX trigger
            const results = [];
            results.push(this.executeAGV1NotifLoad(context));
            return results;
          }
        },
        {
          trigger: 'AGV1detachPartX',
          actions: [
            { name: 'AGV1NotifArriveAUnoaded', body: ['agv1.outNotification.notification = "unloaded";', '// Connection invocation: Notify(agv1, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv1\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV1Events: AGV1detachPartX -> AGV1NotifArriveAUnoaded');
            // Custom logic for AGV1detachPartX trigger
            const results = [];
            results.push(this.executeAGV1NotifArriveAUnoaded(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.AGV1Events.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.AGV1Events.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // AGV2Events Event Definition
    this.AGV2Events = {
      name: 'AGV2Events',
      type: 'rule-based',
      target: 'agv2',
      rules: [
        {
          trigger: 'cmdAGV2toC',
          actions: [
            { name: 'AGV2NotifTravelC', body: ['agv2.outNotification.notification = "traveling";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: cmdAGV2toC -> AGV2NotifTravelC');
            // Custom logic for cmdAGV2toC trigger
            const results = [];
            results.push(this.executeAGV2NotifTravelC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationC',
          actions: [
            { name: 'AGV2NotifArriveC', body: ['agv2.outNotification.notification = "arrived";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2locationStationC -> AGV2NotifArriveC');
            // Custom logic for AGV2locationStationC trigger
            const results = [];
            results.push(this.executeAGV2NotifArriveC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2atachPartX',
          actions: [
            { name: 'AGV2NotifLoad', body: ['agv2.outNotification.notification = "loaded";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2atachPartX -> AGV2NotifLoad');
            // Custom logic for AGV2atachPartX trigger
            const results = [];
            results.push(this.executeAGV2NotifLoad(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationD',
          actions: [
            { name: 'AGV2NotifPassD', body: ['agv2.outNotification.notification = "passed";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2locationStationD -> AGV2NotifPassD');
            // Custom logic for AGV2locationStationD trigger
            const results = [];
            results.push(this.executeAGV2NotifPassD(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationE',
          actions: [
            { name: 'AGV2NotifArriveE', body: ['agv2.outNotification.notification = "arrived";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2locationStationE -> AGV2NotifArriveE');
            // Custom logic for AGV2locationStationE trigger
            const results = [];
            results.push(this.executeAGV2NotifArriveE(context));
            return results;
          }
        },
        {
          trigger: 'AGV2detachPartX',
          actions: [
            { name: 'AGV2NotifArriveAUnoaded', body: ['agv2.outNotification.notification = "unloaded";', '// Connection invocation: Notify(agv2, supervisor)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Notify\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Notify:\', [\'agv2\', \'supervisor\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'supervisor\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Notify: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Notify not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2detachPartX -> AGV2NotifArriveAUnoaded');
            // Custom logic for AGV2detachPartX trigger
            const results = [];
            results.push(this.executeAGV2NotifArriveAUnoaded(context));
            return results;
          }
        },
        {
          trigger: 'AGV2atStationD',
          actions: [
            { name: 'AGV2DetectedStationD', body: ['agv2.sensor = \'stationD\';'] },
          ],
          execute: (context) => {
            console.log('Executing AGV2Events: AGV2atStationD -> AGV2DetectedStationD');
            // Custom logic for AGV2atStationD trigger
            const results = [];
            results.push(this.executeAGV2DetectedStationD(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.AGV2Events.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.AGV2Events.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationAEvents Event Definition
    this.StationAEvents = {
      name: 'StationAEvents',
      type: 'rule-based',
      target: 'stationA',
      rules: [
        {
          trigger: 'agv1.sensor',
          actions: [
            { name: 'AGV1locationStationA', body: ['agv1.location = \'stationA.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationAEvents: agv1.sensor -> AGV1locationStationA');
            // Custom logic for agv1.sensor trigger
            const results = [];
            results.push(this.executeAGV1locationStationA(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationAEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationAEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationBEvents Event Definition
    this.StationBEvents = {
      name: 'StationBEvents',
      type: 'rule-based',
      target: 'stationB',
      rules: [
        {
          trigger: 'agv1.sensor',
          actions: [
            { name: 'AGV1locationStationB', body: ['agv1.location = \'stationB.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationBEvents: agv1.sensor -> AGV1locationStationB');
            // Custom logic for agv1.sensor trigger
            const results = [];
            results.push(this.executeAGV1locationStationB(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationBEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationBEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationCEvents Event Definition
    this.StationCEvents = {
      name: 'StationCEvents',
      type: 'rule-based',
      target: 'stationC',
      rules: [
        {
          trigger: 'agv1.sensor',
          actions: [
            { name: 'AGV1locationStationC', body: ['agv1.location = \'stationC.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationCEvents: agv1.sensor -> AGV1locationStationC');
            // Custom logic for agv1.sensor trigger
            const results = [];
            results.push(this.executeAGV1locationStationC(context));
            return results;
          }
        },
        {
          trigger: 'agv2.sensor',
          actions: [
            { name: 'AGV2locationStationC', body: ['agv2.location = \'stationC.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationCEvents: agv2.sensor -> AGV2locationStationC');
            // Custom logic for agv2.sensor trigger
            const results = [];
            results.push(this.executeAGV2locationStationC(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationCEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationCEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationDEvents Event Definition
    this.StationDEvents = {
      name: 'StationDEvents',
      type: 'rule-based',
      target: 'stationD',
      rules: [
        {
          trigger: 'agv2.sensor',
          actions: [
            { name: 'AGV2locationStationD', body: ['agv2.location = \'stationD.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationDEvents: agv2.sensor -> AGV2locationStationD');
            // Custom logic for agv2.sensor trigger
            const results = [];
            results.push(this.executeAGV2locationStationD(context));
            return results;
          }
        },
        {
          trigger: 'SetAGV2SensorStationD',
          actions: [
            { name: 'UpdateAGV2SensorToD', body: ['agv2.sensor = \'stationD\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationDEvents: SetAGV2SensorStationD -> UpdateAGV2SensorToD');
            // Custom logic for SetAGV2SensorStationD trigger
            const results = [];
            results.push(this.executeUpdateAGV2SensorToD(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationDEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationDEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationEEvents Event Definition
    this.StationEEvents = {
      name: 'StationEEvents',
      type: 'rule-based',
      target: 'stationE',
      rules: [
        {
          trigger: 'agv2.sensor',
          actions: [
            { name: 'agv2locationStationE', body: ['agv2.location = \'stationE.signal\';'] },
          ],
          execute: (context) => {
            console.log('Executing StationEEvents: agv2.sensor -> agv2locationStationE');
            // Custom logic for agv2.sensor trigger
            const results = [];
            results.push(this.executeagv2locationStationE(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationEEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationEEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // PartXEvents Event Definition
    this.PartXEvents = {
      name: 'PartXEvents',
      type: 'rule-based',
      target: 'part',
      rules: [
        {
          trigger: 'cmdAGV1loadA',
          actions: [
            { name: 'AGV1atachPartX', body: ['// Connection invocation: Atach(agv1, part)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Atach\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Atach:\', [\'agv1\', \'part\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'part\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Atach: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Atach not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing PartXEvents: cmdAGV1loadA -> AGV1atachPartX');
            // Custom logic for cmdAGV1loadA trigger
            const results = [];
            results.push(this.executeAGV1atachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV1UnloadA',
          actions: [
            { name: 'AGV1detachPartX', body: ['// Connection invocation: Detach(agv1, part)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Detach\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Detach:\', [\'agv1\', \'part\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv1\';', '    const toEntityName = \'part\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Detach: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Detach not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing PartXEvents: cmdAGV1UnloadA -> AGV1detachPartX');
            // Custom logic for cmdAGV1UnloadA trigger
            const results = [];
            results.push(this.executeAGV1detachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV2loadC',
          actions: [
            { name: 'AGV2atachPartX', body: ['// Connection invocation: Atach(agv2, part)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Atach\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Atach:\', [\'agv2\', \'part\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'part\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Atach: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Atach not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing PartXEvents: cmdAGV2loadC -> AGV2atachPartX');
            // Custom logic for cmdAGV2loadC trigger
            const results = [];
            results.push(this.executeAGV2atachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV2UnloadE',
          actions: [
            { name: 'AGV2detachPartX', body: ['// Connection invocation: Detach(agv2, part)', '// Execute connection between entities', 'if (context.environment && context.environment.connections) {', '  const ConnectionClass = context.environment.connections.find(c => c.name === \'Detach\');', '  if (ConnectionClass) {', '    const connectionInstance = new ConnectionClass();', '    console.log(\'Executing connection Detach:\', [\'agv2\', \'part\']);', '    // Execute message passing between entities', '    const fromEntityName = \'agv2\';', '    const toEntityName = \'part\';', '    const fromEntity = context.entities ? context.entities[fromEntityName] : null;', '    const toEntity = context.entities ? context.entities[toEntityName] : null;', '    ', '    if (fromEntity && toEntity) {', '      console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);', '      ', '      // Simulate message passing based on connection definition', '      if (connectionInstance.from && connectionInstance.to) {', '        const fromRole = connectionInstance.from.split(\'.\')[1]; // e.g., \'outCommand\' from \'Supervisory.outCommand\'', '        const toRole = connectionInstance.to.split(\'.\')[1]; // e.g., \'inCommand\' from \'Vehicle.inCommand\'', '        ', '        console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);', '        ', '        // Trigger event or callback if available', '        if (typeof toEntity.receiveMessage === \'function\') {', '          toEntity.receiveMessage(fromEntityName, fromRole, context);', '        }', '        if (typeof context.onConnectionExecuted === \'function\') {', '          context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);', '        }', '      }', '    } else {', '      console.warn(\'Connection Detach: entities not found in context:\', fromEntityName, toEntityName);', '    }', '  } else {', '    console.warn(\'Connection class Detach not found in environment\');', '  }', '} else {', '  console.warn(\'Environment or connections not available in context\');', '}'] },
          ],
          execute: (context) => {
            console.log('Executing PartXEvents: cmdAGV2UnloadE -> AGV2detachPartX');
            // Custom logic for cmdAGV2UnloadE trigger
            const results = [];
            results.push(this.executeAGV2detachPartX(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.PartXEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.PartXEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

  }

  executecmdAGV2toC(context) {
    console.log('Executing action: cmdAGV2toC');
    // Action implementation:
    supervisor.outCommand.destination = 'stationC';
    supervisor.outCommand.armCommand = 'idle';
    // Connection invocation: Command(supervisor, agv2)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv2']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv2';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV2toC', status: 'executed', context };
  }

  executecmdAGV1toA(context) {
    console.log('Executing action: cmdAGV1toA');
    // Action implementation:
    supervisor.outCommand.destination = 'stationA';
    supervisor.outCommand.armCommand = 'idle';
    // Connection invocation: Command(supervisor, agv1)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv1']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv1';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV1toA', status: 'executed', context };
  }

  executecmdAGV1toC(context) {
    console.log('Executing action: cmdAGV1toC');
    // Action implementation:
    supervisor.outCommand.destination = 'stationA';
    supervisor.outCommand.armCommand = 'idle';
    // Connection invocation: Command(supervisor, agv1)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv1']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv1';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV1toC', status: 'executed', context };
  }

  executecmdAGV1loadA(context) {
    console.log('Executing action: cmdAGV1loadA');
    // Action implementation:
    supervisor.outCommand.destination = 'stationA';
    supervisor.outCommand.armCommand = 'load';
    // Connection invocation: Command(supervisor, agv1)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv1']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv1';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV1loadA', status: 'executed', context };
  }

  executecmdAGV1UnloadA(context) {
    console.log('Executing action: cmdAGV1UnloadA');
    // Action implementation:
    supervisor.outCommand.destination = 'stationA';
    supervisor.outCommand.armCommand = 'unload';
    // Connection invocation: Command(supervisor, agv1)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv1']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv1';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV1UnloadA', status: 'executed', context };
  }

  executecmdAGV2loadC(context) {
    console.log('Executing action: cmdAGV2loadC');
    // Action implementation:
    supervisor.outCommand.destination = 'stationC';
    supervisor.outCommand.armCommand = 'load';
    // Connection invocation: Command(supervisor, agv2)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv2']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv2';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV2loadC', status: 'executed', context };
  }

  executecmdAGV2toE(context) {
    console.log('Executing action: cmdAGV2toE');
    // Action implementation:
    supervisor.outCommand.destination = 'stationE';
    supervisor.outCommand.armCommand = 'idle';
    // Connection invocation: Command(supervisor, agv2)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv2']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv2';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV2toE', status: 'executed', context };
  }

  executecmdAGV2UnloadE(context) {
    console.log('Executing action: cmdAGV2UnloadE');
    // Action implementation:
    supervisor.outCommand.destination = 'stationE';
    supervisor.outCommand.armCommand = 'unload';
    // Connection invocation: Command(supervisor, agv2)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Command');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Command:', ['supervisor', 'agv2']);
        // Execute message passing between entities
        const fromEntityName = 'supervisor';
        const toEntityName = 'agv2';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Command: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Command not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'cmdAGV2UnloadE', status: 'executed', context };
  }

  executeAGV1NotifTravelA(context) {
    console.log('Executing action: AGV1NotifTravelA');
    // Action implementation:
    agv1.outNotification.notification = "traveling";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifTravelA', status: 'executed', context };
  }

  executeAGV1NotifPassB(context) {
    console.log('Executing action: AGV1NotifPassB');
    // Action implementation:
    agv1.outNotification.notification = "passed";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifPassB', status: 'executed', context };
  }

  executeAGV1NotifArriveC(context) {
    console.log('Executing action: AGV1NotifArriveC');
    // Action implementation:
    agv1.outNotification.notification = "arrived";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifArriveC', status: 'executed', context };
  }

  executeAGV1NotifArriveA(context) {
    console.log('Executing action: AGV1NotifArriveA');
    // Action implementation:
    agv1.outNotification.notification = "arrived";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifArriveA', status: 'executed', context };
  }

  executeAGV1NotifLoad(context) {
    console.log('Executing action: AGV1NotifLoad');
    // Action implementation:
    agv1.outNotification.notification = "loaded";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifLoad', status: 'executed', context };
  }

  executeAGV1NotifArriveAUnoaded(context) {
    console.log('Executing action: AGV1NotifArriveAUnoaded');
    // Action implementation:
    agv1.outNotification.notification = "unloaded";
    // Connection invocation: Notify(agv1, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv1', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1NotifArriveAUnoaded', status: 'executed', context };
  }

  executeAGV2NotifTravelC(context) {
    console.log('Executing action: AGV2NotifTravelC');
    // Action implementation:
    agv2.outNotification.notification = "traveling";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifTravelC', status: 'executed', context };
  }

  executeAGV2NotifArriveC(context) {
    console.log('Executing action: AGV2NotifArriveC');
    // Action implementation:
    agv2.outNotification.notification = "arrived";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifArriveC', status: 'executed', context };
  }

  executeAGV2NotifLoad(context) {
    console.log('Executing action: AGV2NotifLoad');
    // Action implementation:
    agv2.outNotification.notification = "loaded";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifLoad', status: 'executed', context };
  }

  executeAGV2NotifPassD(context) {
    console.log('Executing action: AGV2NotifPassD');
    // Action implementation:
    agv2.outNotification.notification = "passed";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifPassD', status: 'executed', context };
  }

  executeAGV2NotifArriveE(context) {
    console.log('Executing action: AGV2NotifArriveE');
    // Action implementation:
    agv2.outNotification.notification = "arrived";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifArriveE', status: 'executed', context };
  }

  executeAGV2NotifArriveAUnoaded(context) {
    console.log('Executing action: AGV2NotifArriveAUnoaded');
    // Action implementation:
    agv2.outNotification.notification = "unloaded";
    // Connection invocation: Notify(agv2, supervisor)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Notify');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Notify:', ['agv2', 'supervisor']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'supervisor';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Notify: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Notify not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2NotifArriveAUnoaded', status: 'executed', context };
  }

  executeAGV2DetectedStationD(context) {
    console.log('Executing action: AGV2DetectedStationD');
    // Action implementation:
    agv2.sensor = 'stationD';
    
    return { action: 'AGV2DetectedStationD', status: 'executed', context };
  }

  executeAGV1locationStationA(context) {
    console.log('Executing action: AGV1locationStationA');
    // Action implementation:
    agv1.location = 'stationA.signal';
    
    return { action: 'AGV1locationStationA', status: 'executed', context };
  }

  executeAGV1locationStationB(context) {
    console.log('Executing action: AGV1locationStationB');
    // Action implementation:
    agv1.location = 'stationB.signal';
    
    return { action: 'AGV1locationStationB', status: 'executed', context };
  }

  executeAGV1locationStationC(context) {
    console.log('Executing action: AGV1locationStationC');
    // Action implementation:
    agv1.location = 'stationC.signal';
    
    return { action: 'AGV1locationStationC', status: 'executed', context };
  }

  executeAGV2locationStationC(context) {
    console.log('Executing action: AGV2locationStationC');
    // Action implementation:
    agv2.location = 'stationC.signal';
    
    return { action: 'AGV2locationStationC', status: 'executed', context };
  }

  executeAGV2locationStationD(context) {
    console.log('Executing action: AGV2locationStationD');
    // Action implementation:
    agv2.location = 'stationD.signal';
    
    return { action: 'AGV2locationStationD', status: 'executed', context };
  }

  executeUpdateAGV2SensorToD(context) {
    console.log('Executing action: UpdateAGV2SensorToD');
    // Action implementation:
    agv2.sensor = 'stationD';
    
    return { action: 'UpdateAGV2SensorToD', status: 'executed', context };
  }

  executeagv2locationStationE(context) {
    console.log('Executing action: agv2locationStationE');
    // Action implementation:
    agv2.location = 'stationE.signal';
    
    return { action: 'agv2locationStationE', status: 'executed', context };
  }

  executeAGV1atachPartX(context) {
    console.log('Executing action: AGV1atachPartX');
    // Action implementation:
    // Connection invocation: Atach(agv1, part)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Atach');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Atach:', ['agv1', 'part']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'part';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Atach: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Atach not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1atachPartX', status: 'executed', context };
  }

  executeAGV1detachPartX(context) {
    console.log('Executing action: AGV1detachPartX');
    // Action implementation:
    // Connection invocation: Detach(agv1, part)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Detach');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Detach:', ['agv1', 'part']);
        // Execute message passing between entities
        const fromEntityName = 'agv1';
        const toEntityName = 'part';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Detach: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Detach not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV1detachPartX', status: 'executed', context };
  }

  executeAGV2atachPartX(context) {
    console.log('Executing action: AGV2atachPartX');
    // Action implementation:
    // Connection invocation: Atach(agv2, part)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Atach');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Atach:', ['agv2', 'part']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'part';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Atach: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Atach not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2atachPartX', status: 'executed', context };
  }

  executeAGV2detachPartX(context) {
    console.log('Executing action: AGV2detachPartX');
    // Action implementation:
    // Connection invocation: Detach(agv2, part)
    // Execute connection between entities
    if (context.environment && context.environment.connections) {
      const ConnectionClass = context.environment.connections.find(c => c.name === 'Detach');
      if (ConnectionClass) {
        const connectionInstance = new ConnectionClass();
        console.log('Executing connection Detach:', ['agv2', 'part']);
        // Execute message passing between entities
        const fromEntityName = 'agv2';
        const toEntityName = 'part';
        const fromEntity = context.entities ? context.entities[fromEntityName] : null;
        const toEntity = context.entities ? context.entities[toEntityName] : null;
        
        if (fromEntity && toEntity) {
          console.log(`Executing connection ${connectionInstance.connectionType} from ${fromEntity.name || fromEntityName} to ${toEntity.name || toEntityName}`);
          
          // Simulate message passing based on connection definition
          if (connectionInstance.from && connectionInstance.to) {
            const fromRole = connectionInstance.from.split('.')[1]; // e.g., 'outCommand' from 'Supervisory.outCommand'
            const toRole = connectionInstance.to.split('.')[1]; // e.g., 'inCommand' from 'Vehicle.inCommand'
            
            console.log(`Message flow: ${fromEntityName}.${fromRole} -> ${toEntityName}.${toRole}`);
            
            // Trigger event or callback if available
            if (typeof toEntity.receiveMessage === 'function') {
              toEntity.receiveMessage(fromEntityName, fromRole, context);
            }
            if (typeof context.onConnectionExecuted === 'function') {
              context.onConnectionExecuted(connectionInstance, fromEntityName, toEntityName, context);
            }
          }
        } else {
          console.warn('Connection Detach: entities not found in context:', fromEntityName, toEntityName);
        }
      } else {
        console.warn('Connection class Detach not found in environment');
      }
    } else {
      console.warn('Environment or connections not available in context');
    }
    
    return { action: 'AGV2detachPartX', status: 'executed', context };
  }

  // Global event execution method
  executeEvent(eventName, triggerName, context) {
    if (this[eventName] && this[eventName].hasRule(triggerName)) {
      return this[eventName].executeRule(triggerName, context);
    }
    console.warn(`Event ${eventName} or trigger ${triggerName} not found`);
    return null;
  }
}

// Scene Definitions: MyScenes
class MyScenes extends SceneDefinitions {
  constructor(name = 'MyScenes', opts = {}) {
    super(name, {
      ...opts,
      targetEvents: 'MyEvents',
      scenes: {}
    });
  }
}

// Scenario Definitions: MyScenarios
class MyScenarios extends ScenarioDefinitions {
  constructor(name = 'MyScenarios', opts = {}) {
    super(name, {
      ...opts,
      targetScenes: 'MyScenes',
      scenarios: {}
    });
  }
}

// Event: events
class events extends Event {
  constructor(name = 'events', opts = {}) {
    super(name, {
      ...opts,
      eventType: 'simple',
      parameters: []
    });
  }
}

// Event: eventClasses
class eventClasses extends Event {
  constructor(name = 'eventClasses', opts = {}) {
    super(name, {
      ...opts,
      eventType: 'simple',
      parameters: []
    });
  }
}

// Enhanced Scene: SCN_MoveAGV1toA
class SCN_MoveAGV1toA extends Scene {
  constructor(name = 'SCN_MoveAGV1toA', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'cmdSupervisor',
      finishEvent: 'AGV1NotifArriveA',
      entities: [],
      initialStates: {}
    });
    
    // Store pre and post conditions for validation
    this.preConditions = [{"expression":"agv1.location == stationC.ID","type":"condition","name":"agv1.location","value":"stationC.ID"},{"expression":"part.location == stationA.ID","type":"condition","name":"part.location","value":"stationA.ID"}];
    this.postConditions = [{"expression":"agv1.location == stationA.ID","type":"condition","name":"agv1.location","value":"stationA.ID"},{"expression":"part.location == stationA.ID","type":"condition","name":"part.location","value":"stationA.ID"}];
  }

  // Validate pre-conditions before scene execution
  async validatePreConditions() {
    this.sysadlBase.logger.log('🔍 Validating pre-conditions for scene: ' + this.name);
    for (const condition of this.preConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Pre-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Pre-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Validate post-conditions after scene execution
  async validatePostConditions() {
    this.sysadlBase.logger.log('🔍 Validating post-conditions for scene: ' + this.name);
    for (const condition of this.postConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Post-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Post-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Trigger start event
  async triggerStartEvent() {
    if (this.startEvent) {
      this.sysadlBase.logger.log('🚀 Triggering start event: ' + this.startEvent);
      await this.sysadlBase.eventInjector.injectEvent(this.startEvent, { source: 'scene:' + this.name });
      return true;
    }
    return false;
  }

  // Wait for finish event
  async waitForFinishEvent() {
    if (this.finishEvent) {
      this.sysadlBase.logger.log('⏳ Waiting for finish event: ' + this.finishEvent);
      return new Promise((resolve) => {
        const handler = (event) => {
          if (event.name === this.finishEvent) {
            this.sysadlBase.logger.log('🏁 Finish event received: ' + this.finishEvent);
            this.sysadlBase.off('event', handler);
            resolve(true);
          }
        };
        this.sysadlBase.on('event', handler);
      });
    }
    return true;
  }

  // Execute complete scene with validation
  async execute() {
    this.sysadlBase.logger.log('🎬 Executing scene: ' + this.name);
    
    // Pre-condition validation
    if (!await this.validatePreConditions()) {
      throw new Error('Pre-conditions not met for scene: ' + this.name);
    }

    // Execute start event
    await this.triggerStartEvent();

    // Wait for finish event
    await this.waitForFinishEvent();

    // Post-condition validation
    if (!await this.validatePostConditions()) {
      throw new Error('Post-conditions not met for scene: ' + this.name);
    }

    this.sysadlBase.logger.log('✅ Scene execution completed successfully: ' + this.name);
    return { success: true, scene: this.name };
  }
}

// Enhanced Scene: SCN_MoveAGV2toC
class SCN_MoveAGV2toC extends Scene {
  constructor(name = 'SCN_MoveAGV2toC', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'cmdAGV2toC',
      finishEvent: 'AGV2NotifArriveC',
      entities: [],
      initialStates: {}
    });
    
    // Store pre and post conditions for validation
    this.preConditions = [{"expression":"agv2.location == stationD.ID","type":"condition","name":"agv2.location","value":"stationD.ID"},{"expression":"part.location == stationA.ID","type":"condition","name":"part.location","value":"stationA.ID"}];
    this.postConditions = [{"expression":"agv2.location == stationC.ID","type":"condition","name":"agv2.location","value":"stationC.ID"},{"expression":"part.location == stationA.ID","type":"condition","name":"part.location","value":"stationA.ID"}];
  }

  // Validate pre-conditions before scene execution
  async validatePreConditions() {
    this.sysadlBase.logger.log('🔍 Validating pre-conditions for scene: ' + this.name);
    for (const condition of this.preConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Pre-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Pre-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Validate post-conditions after scene execution
  async validatePostConditions() {
    this.sysadlBase.logger.log('🔍 Validating post-conditions for scene: ' + this.name);
    for (const condition of this.postConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Post-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Post-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Trigger start event
  async triggerStartEvent() {
    if (this.startEvent) {
      this.sysadlBase.logger.log('🚀 Triggering start event: ' + this.startEvent);
      await this.sysadlBase.eventInjector.injectEvent(this.startEvent, { source: 'scene:' + this.name });
      return true;
    }
    return false;
  }

  // Wait for finish event
  async waitForFinishEvent() {
    if (this.finishEvent) {
      this.sysadlBase.logger.log('⏳ Waiting for finish event: ' + this.finishEvent);
      return new Promise((resolve) => {
        const handler = (event) => {
          if (event.name === this.finishEvent) {
            this.sysadlBase.logger.log('🏁 Finish event received: ' + this.finishEvent);
            this.sysadlBase.off('event', handler);
            resolve(true);
          }
        };
        this.sysadlBase.on('event', handler);
      });
    }
    return true;
  }

  // Execute complete scene with validation
  async execute() {
    this.sysadlBase.logger.log('🎬 Executing scene: ' + this.name);
    
    // Pre-condition validation
    if (!await this.validatePreConditions()) {
      throw new Error('Pre-conditions not met for scene: ' + this.name);
    }

    // Execute start event
    await this.triggerStartEvent();

    // Wait for finish event
    await this.waitForFinishEvent();

    // Post-condition validation
    if (!await this.validatePostConditions()) {
      throw new Error('Post-conditions not met for scene: ' + this.name);
    }

    this.sysadlBase.logger.log('✅ Scene execution completed successfully: ' + this.name);
    return { success: true, scene: this.name };
  }
}

// Enhanced Scene: SCN_AGV1movePartToC
class SCN_AGV1movePartToC extends Scene {
  constructor(name = 'SCN_AGV1movePartToC', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'AGV1NotifArriveA',
      finishEvent: 'AGV1detachPartX',
      entities: [],
      initialStates: {}
    });
    
    // Store pre and post conditions for validation
    this.preConditions = [{"expression":"agv1.location == stationA.ID","type":"condition","name":"agv1.location","value":"stationA.ID"},{"expression":"part.location == stationA.ID","type":"condition","name":"part.location","value":"stationA.ID"}];
    this.postConditions = [{"expression":"agv1.location == stationC.ID","type":"condition","name":"agv1.location","value":"stationC.ID"},{"expression":"part.location == stationC.ID","type":"condition","name":"part.location","value":"stationC.ID"}];
  }

  // Validate pre-conditions before scene execution
  async validatePreConditions() {
    this.sysadlBase.logger.log('🔍 Validating pre-conditions for scene: ' + this.name);
    for (const condition of this.preConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Pre-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Pre-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Validate post-conditions after scene execution
  async validatePostConditions() {
    this.sysadlBase.logger.log('🔍 Validating post-conditions for scene: ' + this.name);
    for (const condition of this.postConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Post-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Post-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Trigger start event
  async triggerStartEvent() {
    if (this.startEvent) {
      this.sysadlBase.logger.log('🚀 Triggering start event: ' + this.startEvent);
      await this.sysadlBase.eventInjector.injectEvent(this.startEvent, { source: 'scene:' + this.name });
      return true;
    }
    return false;
  }

  // Wait for finish event
  async waitForFinishEvent() {
    if (this.finishEvent) {
      this.sysadlBase.logger.log('⏳ Waiting for finish event: ' + this.finishEvent);
      return new Promise((resolve) => {
        const handler = (event) => {
          if (event.name === this.finishEvent) {
            this.sysadlBase.logger.log('🏁 Finish event received: ' + this.finishEvent);
            this.sysadlBase.off('event', handler);
            resolve(true);
          }
        };
        this.sysadlBase.on('event', handler);
      });
    }
    return true;
  }

  // Execute complete scene with validation
  async execute() {
    this.sysadlBase.logger.log('🎬 Executing scene: ' + this.name);
    
    // Pre-condition validation
    if (!await this.validatePreConditions()) {
      throw new Error('Pre-conditions not met for scene: ' + this.name);
    }

    // Execute start event
    await this.triggerStartEvent();

    // Wait for finish event
    await this.waitForFinishEvent();

    // Post-condition validation
    if (!await this.validatePostConditions()) {
      throw new Error('Post-conditions not met for scene: ' + this.name);
    }

    this.sysadlBase.logger.log('✅ Scene execution completed successfully: ' + this.name);
    return { success: true, scene: this.name };
  }
}

// Enhanced Scene: SCN_AGV2movePartToE
class SCN_AGV2movePartToE extends Scene {
  constructor(name = 'SCN_AGV2movePartToE', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'AGV2NotifArriveC',
      finishEvent: 'AGV2detachPartX',
      entities: [],
      initialStates: {}
    });
    
    // Store pre and post conditions for validation
    this.preConditions = [{"expression":"agv2.location == stationC.ID","type":"condition","name":"agv2.location","value":"stationC.ID"},{"expression":"part.location == stationC.ID","type":"condition","name":"part.location","value":"stationC.ID"}];
    this.postConditions = [{"expression":"agv2.location == stationE.ID","type":"condition","name":"agv2.location","value":"stationE.ID"},{"expression":"part.location == stationE.ID","type":"condition","name":"part.location","value":"stationE.ID"}];
  }

  // Validate pre-conditions before scene execution
  async validatePreConditions() {
    this.sysadlBase.logger.log('🔍 Validating pre-conditions for scene: ' + this.name);
    for (const condition of this.preConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Pre-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Pre-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Validate post-conditions after scene execution
  async validatePostConditions() {
    this.sysadlBase.logger.log('🔍 Validating post-conditions for scene: ' + this.name);
    for (const condition of this.postConditions) {
      const result = await this.sysadlBase.conditionWatcher.evaluateCondition(condition.expression || condition);
      if (!result) {
        this.sysadlBase.logger.error('❌ Post-condition failed: ' + (condition.expression || condition));
        return false;
      }
      this.sysadlBase.logger.log('✅ Post-condition passed: ' + (condition.expression || condition));
    }
    return true;
  }

  // Trigger start event
  async triggerStartEvent() {
    if (this.startEvent) {
      this.sysadlBase.logger.log('🚀 Triggering start event: ' + this.startEvent);
      await this.sysadlBase.eventInjector.injectEvent(this.startEvent, { source: 'scene:' + this.name });
      return true;
    }
    return false;
  }

  // Wait for finish event
  async waitForFinishEvent() {
    if (this.finishEvent) {
      this.sysadlBase.logger.log('⏳ Waiting for finish event: ' + this.finishEvent);
      return new Promise((resolve) => {
        const handler = (event) => {
          if (event.name === this.finishEvent) {
            this.sysadlBase.logger.log('🏁 Finish event received: ' + this.finishEvent);
            this.sysadlBase.off('event', handler);
            resolve(true);
          }
        };
        this.sysadlBase.on('event', handler);
      });
    }
    return true;
  }

  // Execute complete scene with validation
  async execute() {
    this.sysadlBase.logger.log('🎬 Executing scene: ' + this.name);
    
    // Pre-condition validation
    if (!await this.validatePreConditions()) {
      throw new Error('Pre-conditions not met for scene: ' + this.name);
    }

    // Execute start event
    await this.triggerStartEvent();

    // Wait for finish event
    await this.waitForFinishEvent();

    // Post-condition validation
    if (!await this.validatePostConditions()) {
      throw new Error('Post-conditions not met for scene: ' + this.name);
    }

    this.sysadlBase.logger.log('✅ Scene execution completed successfully: ' + this.name);
    return { success: true, scene: this.name };
  }
}

// Enhanced Scenario: Scenario1
class Scenario1 extends Scenario {
  constructor(name = 'Scenario1', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario',
      scenes: ["SCN_MoveAGV1toA","SCN_MoveAGV2toC","SCN_AGV1movePartToC","SCN_AGV2movePartToE"],
      preConditions: [],
      postConditions: []
    });
    
    // Store programming structures for execution
    this.programmingStructures = [{"type":"ScenarioRef","name":"SCN_MoveAGV1toA","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31485,"line":1062,"column":5},"end":{"offset":31506,"line":1063,"column":5}}},{"type":"ScenarioRef","name":"SCN_MoveAGV2toC","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31506,"line":1063,"column":5},"end":{"offset":31527,"line":1064,"column":5}}},{"type":"ScenarioRef","name":"SCN_AGV1movePartToC","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31527,"line":1064,"column":5},"end":{"offset":31552,"line":1065,"column":5}}},{"type":"ScenarioRef","name":"SCN_AGV2movePartToE","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31552,"line":1065,"column":5},"end":{"offset":31575,"line":1066,"column":3}}}];
  }

  // Execute scene by name
  async executeScene(sceneName) {
    this.sysadlBase.logger.log('🎬 Executing scene from scenario: ' + sceneName);
    return await this.sysadlBase.sceneExecutor.executeScene(sceneName);
  }

  // Execute scenario by name
  async executeScenario(scenarioName) {
    this.sysadlBase.logger.log('🎭 Executing scenario from scenario: ' + scenarioName);
    return await this.sysadlBase.scenarioExecutor.executeScenario(scenarioName);
  }

  // Execute variable declaration
  async executeVariableDeclaration(varDecl, context) {
    const varName = varDecl.name;
    let value = 1; // Default value
    
    // Extract value from AST structure
    if (varDecl.value && Array.isArray(varDecl.value) && varDecl.value.length >= 3) {
      const valueNode = varDecl.value[2];
      if (valueNode && valueNode.type === 'NaturalLiteral') {
        value = valueNode.value;
      }
    }
    
    context[varName] = value;
    this.sysadlBase.logger.log('📊 Variable declared: ' + varName + ' = ' + value);
    return true;
  }

  // Execute while loop with programming structures
  async executeWhileLoop(whileStmt, context) {
    const condition = whileStmt.condition;
    const body = whileStmt.body;
    
    this.sysadlBase.logger.log('🔄 Executing while loop with condition');
    
    while (await this.evaluateCondition(condition, context)) {
      this.sysadlBase.logger.log('🔄 While loop iteration, context: ' + JSON.stringify(context));
      
      // Execute body statements
      if (body && body.body && Array.isArray(body.body)) {
        for (const stmt of body.body) {
          await this.executeStatement(stmt, context);
        }
      }
    }
    
    this.sysadlBase.logger.log('✅ While loop completed');
    return true;
  }

  // Evaluate condition expression
  async evaluateCondition(condition, context) {
    if (condition.type === 'BinaryExpression') {
      const left = await this.evaluateExpression(condition.left, context);
      const right = await this.evaluateExpression(condition.right, context);
      
      switch (condition.operator) {
        case '<': return left < right;
        case '>': return left > right;
        case '<=': return left <= right;
        case '>=': return left >= right;
        case '==': return left == right;
        case '!=': return left != right;
        default: return false;
      }
    }
    return false;
  }

  // Evaluate expression
  async evaluateExpression(expr, context) {
    if (expr.type === 'NameExpression') {
      return context[expr.name] || 0;
    } else if (expr.type === 'NaturalLiteral') {
      return expr.value;
    }
    return 0;
  }

  // Execute increment/decrement
  async executeIncDec(incDecStmt, context) {
    const varName = incDecStmt.name;
    const operation = incDecStmt.op;
    
    if (operation === '++') {
      context[varName] = (context[varName] || 0) + 1;
    } else if (operation === '--') {
      context[varName] = (context[varName] || 0) - 1;
    }
    
    this.sysadlBase.logger.log('📊 Variable updated: ' + varName + ' ' + operation + ' = ' + context[varName]);
    return true;
  }

  // Execute any statement
  async executeStatement(stmt, context) {
    switch (stmt.type) {
      case 'VariableDecl':
        return await this.executeVariableDeclaration(stmt, context);
      case 'WhileStatement':
        return await this.executeWhileLoop(stmt, context);
      case 'IncDec':
        return await this.executeIncDec(stmt, context);
      case 'ScenarioRef':
        // Check if it's a Scene or Scenario reference
        if (stmt.name.startsWith('SCN_')) {
          return await this.executeScene(stmt.name);
        } else {
          return await this.executeScenario(stmt.name);
        }
      default:
        this.sysadlBase.logger.warn('⚠️ Unknown statement type: ' + stmt.type);
        return true;
    }
  }

  // Execute complete scenario with programming structures
  async execute() {
    this.sysadlBase.logger.log('🎭 Executing scenario: ' + this.name);
    
    // Initialize execution context
    const context = {};
    
    // Execute all programming structures
    for (const stmt of this.programmingStructures) {
      await this.executeStatement(stmt, context);
    }
    
    this.sysadlBase.logger.log('✅ Scenario execution completed successfully: ' + this.name);
    return { success: true, scenario: this.name, context };
  }
}

// Enhanced Scenario: Scenario2
class Scenario2 extends Scenario {
  constructor(name = 'Scenario2', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario',
      scenes: ["SCN_MoveAGV1toA","SCN_MoveAGV2toC","SCN_AGV2movePartToE","SCN_AGV1movePartToC"],
      preConditions: [],
      postConditions: []
    });
    
    // Store programming structures for execution
    this.programmingStructures = [{"type":"ScenarioRef","name":"SCN_MoveAGV1toA","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31627,"line":1068,"column":5},"end":{"offset":31648,"line":1069,"column":5}}},{"type":"ScenarioRef","name":"SCN_MoveAGV2toC","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31648,"line":1069,"column":5},"end":{"offset":31669,"line":1070,"column":5}}},{"type":"ScenarioRef","name":"SCN_AGV2movePartToE","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31669,"line":1070,"column":5},"end":{"offset":31733,"line":1071,"column":5}}},{"type":"ScenarioRef","name":"SCN_AGV1movePartToC","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31733,"line":1071,"column":5},"end":{"offset":31756,"line":1072,"column":3}}}];
  }

  // Execute scene by name
  async executeScene(sceneName) {
    this.sysadlBase.logger.log('🎬 Executing scene from scenario: ' + sceneName);
    return await this.sysadlBase.sceneExecutor.executeScene(sceneName);
  }

  // Execute scenario by name
  async executeScenario(scenarioName) {
    this.sysadlBase.logger.log('🎭 Executing scenario from scenario: ' + scenarioName);
    return await this.sysadlBase.scenarioExecutor.executeScenario(scenarioName);
  }

  // Execute variable declaration
  async executeVariableDeclaration(varDecl, context) {
    const varName = varDecl.name;
    let value = 1; // Default value
    
    // Extract value from AST structure
    if (varDecl.value && Array.isArray(varDecl.value) && varDecl.value.length >= 3) {
      const valueNode = varDecl.value[2];
      if (valueNode && valueNode.type === 'NaturalLiteral') {
        value = valueNode.value;
      }
    }
    
    context[varName] = value;
    this.sysadlBase.logger.log('📊 Variable declared: ' + varName + ' = ' + value);
    return true;
  }

  // Execute while loop with programming structures
  async executeWhileLoop(whileStmt, context) {
    const condition = whileStmt.condition;
    const body = whileStmt.body;
    
    this.sysadlBase.logger.log('🔄 Executing while loop with condition');
    
    while (await this.evaluateCondition(condition, context)) {
      this.sysadlBase.logger.log('🔄 While loop iteration, context: ' + JSON.stringify(context));
      
      // Execute body statements
      if (body && body.body && Array.isArray(body.body)) {
        for (const stmt of body.body) {
          await this.executeStatement(stmt, context);
        }
      }
    }
    
    this.sysadlBase.logger.log('✅ While loop completed');
    return true;
  }

  // Evaluate condition expression
  async evaluateCondition(condition, context) {
    if (condition.type === 'BinaryExpression') {
      const left = await this.evaluateExpression(condition.left, context);
      const right = await this.evaluateExpression(condition.right, context);
      
      switch (condition.operator) {
        case '<': return left < right;
        case '>': return left > right;
        case '<=': return left <= right;
        case '>=': return left >= right;
        case '==': return left == right;
        case '!=': return left != right;
        default: return false;
      }
    }
    return false;
  }

  // Evaluate expression
  async evaluateExpression(expr, context) {
    if (expr.type === 'NameExpression') {
      return context[expr.name] || 0;
    } else if (expr.type === 'NaturalLiteral') {
      return expr.value;
    }
    return 0;
  }

  // Execute increment/decrement
  async executeIncDec(incDecStmt, context) {
    const varName = incDecStmt.name;
    const operation = incDecStmt.op;
    
    if (operation === '++') {
      context[varName] = (context[varName] || 0) + 1;
    } else if (operation === '--') {
      context[varName] = (context[varName] || 0) - 1;
    }
    
    this.sysadlBase.logger.log('📊 Variable updated: ' + varName + ' ' + operation + ' = ' + context[varName]);
    return true;
  }

  // Execute any statement
  async executeStatement(stmt, context) {
    switch (stmt.type) {
      case 'VariableDecl':
        return await this.executeVariableDeclaration(stmt, context);
      case 'WhileStatement':
        return await this.executeWhileLoop(stmt, context);
      case 'IncDec':
        return await this.executeIncDec(stmt, context);
      case 'ScenarioRef':
        // Check if it's a Scene or Scenario reference
        if (stmt.name.startsWith('SCN_')) {
          return await this.executeScene(stmt.name);
        } else {
          return await this.executeScenario(stmt.name);
        }
      default:
        this.sysadlBase.logger.warn('⚠️ Unknown statement type: ' + stmt.type);
        return true;
    }
  }

  // Execute complete scenario with programming structures
  async execute() {
    this.sysadlBase.logger.log('🎭 Executing scenario: ' + this.name);
    
    // Initialize execution context
    const context = {};
    
    // Execute all programming structures
    for (const stmt of this.programmingStructures) {
      await this.executeStatement(stmt, context);
    }
    
    this.sysadlBase.logger.log('✅ Scenario execution completed successfully: ' + this.name);
    return { success: true, scenario: this.name, context };
  }
}

// Enhanced Scenario: Scenario3
class Scenario3 extends Scenario {
  constructor(name = 'Scenario3', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario',
      scenes: ["SCN_MoveAGV1toA","SCN_AGV1movePartToC"],
      preConditions: [],
      postConditions: []
    });
    
    // Store programming structures for execution
    this.programmingStructures = [{"type":"VariableDecl","name":"i","definition":"Integer","arrayIndex":null,"value":["=",[" "],{"type":"NaturalLiteral","value":1,"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31836,"line":1074,"column":23},"end":{"offset":31837,"line":1074,"column":24}}}],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31819,"line":1074,"column":6},"end":{"offset":31838,"line":1074,"column":25}}},{"type":"WhileStatement","condition":{"type":"BinaryExpression","operator":"<","left":{"type":"NameExpression","name":"i","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31851,"line":1075,"column":13},"end":{"offset":31852,"line":1075,"column":14}}},"right":{"type":"NaturalLiteral","value":5,"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31855,"line":1075,"column":17},"end":{"offset":31856,"line":1075,"column":18}}},"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31851,"line":1075,"column":13},"end":{"offset":31856,"line":1075,"column":18}}},"body":{"type":"BlockStatement","body":[{"type":"ScenarioRef","name":"SCN_MoveAGV1toA","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31867,"line":1076,"column":8},"end":{"offset":31891,"line":1077,"column":8}}},{"type":"ScenarioRef","name":"SCN_AGV1movePartToC","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31891,"line":1077,"column":8},"end":{"offset":31919,"line":1078,"column":8}}},{"type":"IncDec","name":"i","op":"++","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31919,"line":1078,"column":8},"end":{"offset":31923,"line":1078,"column":12}}}],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31858,"line":1075,"column":20},"end":{"offset":31930,"line":1079,"column":7}}},"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31844,"line":1075,"column":6},"end":{"offset":31930,"line":1079,"column":7}}}];
  }

  // Execute scene by name
  async executeScene(sceneName) {
    this.sysadlBase.logger.log('🎬 Executing scene from scenario: ' + sceneName);
    return await this.sysadlBase.sceneExecutor.executeScene(sceneName);
  }

  // Execute scenario by name
  async executeScenario(scenarioName) {
    this.sysadlBase.logger.log('🎭 Executing scenario from scenario: ' + scenarioName);
    return await this.sysadlBase.scenarioExecutor.executeScenario(scenarioName);
  }

  // Execute variable declaration
  async executeVariableDeclaration(varDecl, context) {
    const varName = varDecl.name;
    let value = 1; // Default value
    
    // Extract value from AST structure
    if (varDecl.value && Array.isArray(varDecl.value) && varDecl.value.length >= 3) {
      const valueNode = varDecl.value[2];
      if (valueNode && valueNode.type === 'NaturalLiteral') {
        value = valueNode.value;
      }
    }
    
    context[varName] = value;
    this.sysadlBase.logger.log('📊 Variable declared: ' + varName + ' = ' + value);
    return true;
  }

  // Execute while loop with programming structures
  async executeWhileLoop(whileStmt, context) {
    const condition = whileStmt.condition;
    const body = whileStmt.body;
    
    this.sysadlBase.logger.log('🔄 Executing while loop with condition');
    
    while (await this.evaluateCondition(condition, context)) {
      this.sysadlBase.logger.log('🔄 While loop iteration, context: ' + JSON.stringify(context));
      
      // Execute body statements
      if (body && body.body && Array.isArray(body.body)) {
        for (const stmt of body.body) {
          await this.executeStatement(stmt, context);
        }
      }
    }
    
    this.sysadlBase.logger.log('✅ While loop completed');
    return true;
  }

  // Evaluate condition expression
  async evaluateCondition(condition, context) {
    if (condition.type === 'BinaryExpression') {
      const left = await this.evaluateExpression(condition.left, context);
      const right = await this.evaluateExpression(condition.right, context);
      
      switch (condition.operator) {
        case '<': return left < right;
        case '>': return left > right;
        case '<=': return left <= right;
        case '>=': return left >= right;
        case '==': return left == right;
        case '!=': return left != right;
        default: return false;
      }
    }
    return false;
  }

  // Evaluate expression
  async evaluateExpression(expr, context) {
    if (expr.type === 'NameExpression') {
      return context[expr.name] || 0;
    } else if (expr.type === 'NaturalLiteral') {
      return expr.value;
    }
    return 0;
  }

  // Execute increment/decrement
  async executeIncDec(incDecStmt, context) {
    const varName = incDecStmt.name;
    const operation = incDecStmt.op;
    
    if (operation === '++') {
      context[varName] = (context[varName] || 0) + 1;
    } else if (operation === '--') {
      context[varName] = (context[varName] || 0) - 1;
    }
    
    this.sysadlBase.logger.log('📊 Variable updated: ' + varName + ' ' + operation + ' = ' + context[varName]);
    return true;
  }

  // Execute any statement
  async executeStatement(stmt, context) {
    switch (stmt.type) {
      case 'VariableDecl':
        return await this.executeVariableDeclaration(stmt, context);
      case 'WhileStatement':
        return await this.executeWhileLoop(stmt, context);
      case 'IncDec':
        return await this.executeIncDec(stmt, context);
      case 'ScenarioRef':
        // Check if it's a Scene or Scenario reference
        if (stmt.name.startsWith('SCN_')) {
          return await this.executeScene(stmt.name);
        } else {
          return await this.executeScenario(stmt.name);
        }
      default:
        this.sysadlBase.logger.warn('⚠️ Unknown statement type: ' + stmt.type);
        return true;
    }
  }

  // Execute complete scenario with programming structures
  async execute() {
    this.sysadlBase.logger.log('🎭 Executing scenario: ' + this.name);
    
    // Initialize execution context
    const context = {};
    
    // Execute all programming structures
    for (const stmt of this.programmingStructures) {
      await this.executeStatement(stmt, context);
    }
    
    this.sysadlBase.logger.log('✅ Scenario execution completed successfully: ' + this.name);
    return { success: true, scenario: this.name, context };
  }
}

// Enhanced Scenario: Scenario4
class Scenario4 extends Scenario {
  constructor(name = 'Scenario4', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario',
      scenes: ["Scenario1"],
      preConditions: [],
      postConditions: []
    });
    
    // Store programming structures for execution
    this.programmingStructures = [{"type":"VariableDecl","name":"i","definition":"Integer","arrayIndex":null,"value":["=",[" "],{"type":"NaturalLiteral","value":1,"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32014,"line":1082,"column":23},"end":{"offset":32015,"line":1082,"column":24}}}],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":31997,"line":1082,"column":6},"end":{"offset":32016,"line":1082,"column":25}}},{"type":"WhileStatement","condition":{"type":"BinaryExpression","operator":"<","left":{"type":"NameExpression","name":"i","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32029,"line":1083,"column":13},"end":{"offset":32030,"line":1083,"column":14}}},"right":{"type":"NaturalLiteral","value":5,"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32033,"line":1083,"column":17},"end":{"offset":32034,"line":1083,"column":18}}},"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32029,"line":1083,"column":13},"end":{"offset":32034,"line":1083,"column":18}}},"body":{"type":"BlockStatement","body":[{"type":"ScenarioRef","name":"Scenario1","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32045,"line":1084,"column":8},"end":{"offset":32063,"line":1085,"column":8}}},{"type":"IncDec","name":"i","op":"++","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32063,"line":1085,"column":8},"end":{"offset":32067,"line":1085,"column":12}}}],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32036,"line":1083,"column":20},"end":{"offset":32069,"line":1085,"column":14}}},"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32022,"line":1083,"column":6},"end":{"offset":32069,"line":1085,"column":14}}}];
  }

  // Execute scene by name
  async executeScene(sceneName) {
    this.sysadlBase.logger.log('🎬 Executing scene from scenario: ' + sceneName);
    return await this.sysadlBase.sceneExecutor.executeScene(sceneName);
  }

  // Execute scenario by name
  async executeScenario(scenarioName) {
    this.sysadlBase.logger.log('🎭 Executing scenario from scenario: ' + scenarioName);
    return await this.sysadlBase.scenarioExecutor.executeScenario(scenarioName);
  }

  // Execute variable declaration
  async executeVariableDeclaration(varDecl, context) {
    const varName = varDecl.name;
    let value = 1; // Default value
    
    // Extract value from AST structure
    if (varDecl.value && Array.isArray(varDecl.value) && varDecl.value.length >= 3) {
      const valueNode = varDecl.value[2];
      if (valueNode && valueNode.type === 'NaturalLiteral') {
        value = valueNode.value;
      }
    }
    
    context[varName] = value;
    this.sysadlBase.logger.log('📊 Variable declared: ' + varName + ' = ' + value);
    return true;
  }

  // Execute while loop with programming structures
  async executeWhileLoop(whileStmt, context) {
    const condition = whileStmt.condition;
    const body = whileStmt.body;
    
    this.sysadlBase.logger.log('🔄 Executing while loop with condition');
    
    while (await this.evaluateCondition(condition, context)) {
      this.sysadlBase.logger.log('🔄 While loop iteration, context: ' + JSON.stringify(context));
      
      // Execute body statements
      if (body && body.body && Array.isArray(body.body)) {
        for (const stmt of body.body) {
          await this.executeStatement(stmt, context);
        }
      }
    }
    
    this.sysadlBase.logger.log('✅ While loop completed');
    return true;
  }

  // Evaluate condition expression
  async evaluateCondition(condition, context) {
    if (condition.type === 'BinaryExpression') {
      const left = await this.evaluateExpression(condition.left, context);
      const right = await this.evaluateExpression(condition.right, context);
      
      switch (condition.operator) {
        case '<': return left < right;
        case '>': return left > right;
        case '<=': return left <= right;
        case '>=': return left >= right;
        case '==': return left == right;
        case '!=': return left != right;
        default: return false;
      }
    }
    return false;
  }

  // Evaluate expression
  async evaluateExpression(expr, context) {
    if (expr.type === 'NameExpression') {
      return context[expr.name] || 0;
    } else if (expr.type === 'NaturalLiteral') {
      return expr.value;
    }
    return 0;
  }

  // Execute increment/decrement
  async executeIncDec(incDecStmt, context) {
    const varName = incDecStmt.name;
    const operation = incDecStmt.op;
    
    if (operation === '++') {
      context[varName] = (context[varName] || 0) + 1;
    } else if (operation === '--') {
      context[varName] = (context[varName] || 0) - 1;
    }
    
    this.sysadlBase.logger.log('📊 Variable updated: ' + varName + ' ' + operation + ' = ' + context[varName]);
    return true;
  }

  // Execute any statement
  async executeStatement(stmt, context) {
    switch (stmt.type) {
      case 'VariableDecl':
        return await this.executeVariableDeclaration(stmt, context);
      case 'WhileStatement':
        return await this.executeWhileLoop(stmt, context);
      case 'IncDec':
        return await this.executeIncDec(stmt, context);
      case 'ScenarioRef':
        // Check if it's a Scene or Scenario reference
        if (stmt.name.startsWith('SCN_')) {
          return await this.executeScene(stmt.name);
        } else {
          return await this.executeScenario(stmt.name);
        }
      default:
        this.sysadlBase.logger.warn('⚠️ Unknown statement type: ' + stmt.type);
        return true;
    }
  }

  // Execute complete scenario with programming structures
  async execute() {
    this.sysadlBase.logger.log('🎭 Executing scenario: ' + this.name);
    
    // Initialize execution context
    const context = {};
    
    // Execute all programming structures
    for (const stmt of this.programmingStructures) {
      await this.executeStatement(stmt, context);
    }
    
    this.sysadlBase.logger.log('✅ Scenario execution completed successfully: ' + this.name);
    return { success: true, scenario: this.name, context };
  }
}

// Enhanced Scenario Execution: MyScenariosExecution
class MyScenariosExecution extends ScenarioExecution {
  constructor(name = 'MyScenariosExecution', opts = {}) {
    super(name, {
      ...opts,
      targetScenarios: 'MyScenarios',
      scenarios: [{"type":"scenario","name":"Scenario1","mode":"normal"},{"type":"scenario","name":"Scenario2","mode":"normal"},{"type":"scenario","name":"Scenario3","mode":"normal"},{"type":"scenario","name":"Scenario4","mode":"normal"}],
      executionMode: 'sequential',
      stateInitializations: [{"type":"assignment","target":"agv1.location","value":"stationC.ID","source":{"type":"NameExpression","name":"stationC.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32130,"line":1090,"column":19},"end":{"offset":32141,"line":1090,"column":30}}}},{"type":"assignment","target":"agv2.location","value":"stationD.ID","source":{"type":"NameExpression","name":"stationD.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32161,"line":1091,"column":19},"end":{"offset":32172,"line":1091,"column":30}}}},{"type":"assignment","target":"part.location","value":"stationA.ID","source":{"type":"NameExpression","name":"stationA.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32192,"line":1092,"column":19},"end":{"offset":32203,"line":1092,"column":30}}}}],
      repeatStatements: [{"type":"repeat","count":5,"scenario":"Scenario1"}]
    });
    
    // Store execution configuration for runtime
    this.executionConfig = {
      stateInitializations: [{"type":"assignment","target":"agv1.location","value":"stationC.ID","source":{"type":"NameExpression","name":"stationC.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32130,"line":1090,"column":19},"end":{"offset":32141,"line":1090,"column":30}}}},{"type":"assignment","target":"agv2.location","value":"stationD.ID","source":{"type":"NameExpression","name":"stationD.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32161,"line":1091,"column":19},"end":{"offset":32172,"line":1091,"column":30}}}},{"type":"assignment","target":"part.location","value":"stationA.ID","source":{"type":"NameExpression","name":"stationA.ID","location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEntity def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\troles {\n\t\t\tRole def signal \n\t\t}\n\t}\n\n\tEntity def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\troles {\n\t\t\tRole def surface \n\t\t}\n\t}\n\n\tEntity def Lane {\n\t\tentities {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEntity def Supervisory {\n\t\troles {\n\t\t\tRole def inNotification   \n\t\t\tRole def outCommand   \n\t\t}\n\t}\n\n\tEntity def Vehicle {\n\t\troles {\n\t\t\tRole def outNotification \n\t\t\tRole def inCommand  \n\t\t\tRole def sensor  \t\n\t\t\tRole def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tConnection def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tConnection def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tConnection def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tConnection def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tConnection def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":32192,"line":1092,"column":19},"end":{"offset":32203,"line":1092,"column":30}}}}],
      scenarios: [{"type":"scenario","name":"Scenario1","mode":"normal"},{"type":"scenario","name":"Scenario2","mode":"normal"},{"type":"scenario","name":"Scenario3","mode":"normal"},{"type":"scenario","name":"Scenario4","mode":"normal"}],
      repeatStatements: [{"type":"repeat","count":5,"scenario":"Scenario1"}],
      eventInjections: []
    };
  }
  
  // Initialize environment state before execution
  async initializeState() {
    this.sysadlBase.logger.log('🔧 Initializing scenario execution state');
    
    for (const init of this.executionConfig.stateInitializations) {
      await this.executeStateInitialization(init);
    }
    
    this.sysadlBase.logger.log('✅ State initialization completed');
    return true;
  }
  
  // Execute state initialization
  async executeStateInitialization(init) {
    const target = init.target;
    const value = init.value;
    
    this.sysadlBase.logger.log(`📊 Setting ${target} = ${value}`);
    
    // Parse target path and set value
    const pathParts = target.split('.');
    let currentObject = this.sysadlBase.environmentConfig;
    
    // Navigate to parent object
    for (let i = 0; i < pathParts.length - 1; i++) {
      if (currentObject[pathParts[i]]) {
        currentObject = currentObject[pathParts[i]];
      } else {
        this.sysadlBase.logger.log(`⚠️ Could not find path: ${pathParts.slice(0, i + 1).join('.')}`);
        return false;
      }
    }
    
    // Set final property
    const propertyName = pathParts[pathParts.length - 1];
    currentObject[propertyName] = value;
    
    return true;
  }
  
  // Execute scenario with repeat support
  async executeScenarioWithRepeat(scenarioName, repeatCount = 1) {
    this.sysadlBase.logger.log(`🔄 Executing ${scenarioName} ${repeatCount} times`);
    
    for (let i = 0; i < repeatCount; i++) {
      this.sysadlBase.logger.log(`🔄 Iteration ${i + 1}/${repeatCount} of ${scenarioName}`);
      await this.executeScenario(scenarioName);
    }
    
    this.sysadlBase.logger.log(`✅ Completed ${repeatCount} executions of ${scenarioName}`);
    return true;
  }
  
  // Enhanced execution with state initialization, repeat support, and event injection
  async executeEnhanced() {
    this.sysadlBase.logger.log('🚀 Starting enhanced scenario execution');
    
    // Step 1: Initialize state
    await this.initializeState();
    
    // Step 2: Process event injections
    await this.processEventInjections();
    
    // Step 3: Execute scenarios
    for (const scenario of this.executionConfig.scenarios) {
      await this.executeScenario(scenario.name);
    }
    
    // Step 4: Execute repeat statements
    for (const repeat of this.executionConfig.repeatStatements) {
      await this.executeScenarioWithRepeat(repeat.scenario, repeat.count);
    }
    
    this.sysadlBase.logger.log('✅ Enhanced scenario execution completed');
    return true;
  }
  
  // Process event injections
  async processEventInjections() {
    if (!this.executionConfig.eventInjections || this.executionConfig.eventInjections.length === 0) {
      return;
    }
    
    this.sysadlBase.logger.log('⚡ Processing event injections');
    
    for (const injection of this.executionConfig.eventInjections) {
      await this.executeEventInjection(injection);
    }
  }
  
  // Execute a single event injection
  async executeEventInjection(injection) {
    try {
      if (injection.type === 'single') {
        await this.injectSingleEvent(injection);
      } else if (injection.type === 'batch') {
        await this.injectBatchEvents(injection);
      }
    } catch (error) {
      this.sysadlBase.logger.log(`❌ Event injection failed: ${error.message}`);
      throw error;
    }
  }
  
  // Inject a single event
  async injectSingleEvent(injection) {
    const delay = this.calculateEventDelay(injection.timing);
    
    this.sysadlBase.logger.log(`⚡ Injecting event: ${injection.eventName} (delay: ${delay}ms)`);
    
    return await this.sysadlBase.eventInjector.injectEvent(
      injection.eventName,
      injection.parameters,
      delay,
      injection.options
    );
  }
  
  // Inject batch events
  async injectBatchEvents(injection) {
    const eventSpecs = injection.events.map(eventName => ({
      eventName,
      parameters: injection.parameters || {},
      delay: this.calculateEventDelay(injection.timing),
      options: injection.options || {}
    }));
    
    this.sysadlBase.logger.log(`⚡ Injecting batch events: ${injection.events.join(', ')} (mode: ${injection.mode})`);
    
    return await this.sysadlBase.eventInjector.injectEventBatch(
      eventSpecs,
      { parallel: injection.mode === 'parallel' }
    );
  }
  
  // Calculate event delay based on timing specification
  calculateEventDelay(timing) {
    if (!timing) return 0;
    
    switch (timing.type) {
      case 'delay':
        return timing.value || 0;
      case 'immediate':
        return 0;
      case 'condition':
        // For conditions, evaluate later - return 0 for now
        return 0;
      case 'before':
      case 'after':
        // For scenario-relative timing, coordinate with scenario execution
        return 0;
      default:
        return 0;
    }
  }
}

function createEnvironmentModel() {
  const model = createModel(); // Get traditional model
  
  // Initialize scenario execution capabilities
  model.initializeScenarioExecution();
  
  // Add environment/scenario elements to model
  model.environments = {};
  model.events = {};
  model.scenes = {};
  model.scenarios = {};
  model.scenarioExecutions = {};
  
  model.environments['MyFactory'] = new MyFactory();
  model.environments['MyFactoryConfiguration'] = new MyFactoryConfiguration();
  model.events['MyEvents'] = new MyEvents();
  model.scenes['MyScenes'] = new MyScenes();
  model.scenarios['MyScenarios'] = new MyScenarios();
  model.scenarioExecutions['MyScenariosExecution'] = new MyScenariosExecution();
  model.registerScenarioExecution(model.scenarioExecutions['MyScenariosExecution']);
  
  // Setup environment bindings if needed
  // TODO: Implement automatic binding setup based on model analysis
  
  return model;
}

module.exports = { createEnvironmentModel, MyFactory, MyFactoryConfiguration, MyEvents, MyScenes, MyScenarios, MyScenariosExecution };