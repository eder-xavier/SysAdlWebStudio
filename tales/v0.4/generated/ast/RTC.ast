{
  "type": "Model",
  "name": "SysADLModel",
  "involvedElements": [],
  "members": [
    {
      "type": "Package",
      "name": "types",
      "appliedStyle": null,
      "imports": [],
      "importedDefinitions": [],
      "definitions": [
        {
          "type": "ValueTypeDef",
          "name": "Int",
          "superType": null,
          "unit": null,
          "dimension": null,
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 39,
              "line": 3,
              "column": 3
            },
            "end": {
              "offset": 56,
              "line": 3,
              "column": 20
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "Boolean",
          "superType": null,
          "unit": null,
          "dimension": null,
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 59,
              "line": 4,
              "column": 3
            },
            "end": {
              "offset": 80,
              "line": 4,
              "column": 24
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "String",
          "superType": null,
          "unit": null,
          "dimension": null,
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 83,
              "line": 5,
              "column": 3
            },
            "end": {
              "offset": 103,
              "line": 5,
              "column": 23
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "Void",
          "superType": null,
          "unit": null,
          "dimension": null,
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 106,
              "line": 6,
              "column": 3
            },
            "end": {
              "offset": 124,
              "line": 6,
              "column": 21
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "Real",
          "superType": null,
          "unit": null,
          "dimension": null,
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 127,
              "line": 7,
              "column": 3
            },
            "end": {
              "offset": 145,
              "line": 7,
              "column": 21
            }
          }
        },
        {
          "type": "Enumeration",
          "name": "Command",
          "properties": [],
          "literals": [
            {
              "type": "EnumLiteralValue",
              "name": "On",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 162,
                  "line": 8,
                  "column": 17
                },
                "end": {
                  "offset": 164,
                  "line": 8,
                  "column": 19
                }
              }
            },
            {
              "type": "EnumLiteralValue",
              "name": "Off",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 167,
                  "line": 8,
                  "column": 22
                },
                "end": {
                  "offset": 170,
                  "line": 8,
                  "column": 25
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 148,
              "line": 8,
              "column": 3
            },
            "end": {
              "offset": 172,
              "line": 8,
              "column": 27
            }
          }
        },
        {
          "type": "DataTypeDef",
          "name": "Commands",
          "superType": null,
          "attributes": [
            {
              "type": "TypeUse",
              "name": "heater",
              "definition": "Command",
              "arrayIndex": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 207,
                  "line": 9,
                  "column": 35
                },
                "end": {
                  "offset": 225,
                  "line": 9,
                  "column": 53
                }
              }
            },
            {
              "type": "TypeUse",
              "name": "cooler",
              "definition": "Command",
              "arrayIndex": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 226,
                  "line": 9,
                  "column": 54
                },
                "end": {
                  "offset": 244,
                  "line": 9,
                  "column": 72
                }
              }
            }
          ],
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 175,
              "line": 9,
              "column": 3
            },
            "end": {
              "offset": 246,
              "line": 9,
              "column": 74
            }
          }
        },
        {
          "type": "DimensionDef",
          "name": "Temperature",
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 249,
              "line": 10,
              "column": 3
            },
            "end": {
              "offset": 271,
              "line": 10,
              "column": 25
            }
          }
        },
        {
          "type": "UnitDef",
          "name": "Celsius",
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 271,
              "line": 10,
              "column": 25
            },
            "end": {
              "offset": 310,
              "line": 10,
              "column": 64
            }
          }
        },
        {
          "type": "UnitDef",
          "name": "Fahrenheit",
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 313,
              "line": 11,
              "column": 3
            },
            "end": {
              "offset": 355,
              "line": 11,
              "column": 45
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "temperature",
          "superType": "Real",
          "unit": null,
          "dimension": "Temperature",
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 358,
              "line": 12,
              "column": 3
            },
            "end": {
              "offset": 421,
              "line": 12,
              "column": 66
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "FahrenheitTemperature",
          "superType": "temperature",
          "unit": "Fahrenheit",
          "dimension": "Temperature",
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 424,
              "line": 13,
              "column": 3
            },
            "end": {
              "offset": 522,
              "line": 13,
              "column": 101
            }
          }
        },
        {
          "type": "ValueTypeDef",
          "name": "CelsiusTemperature",
          "superType": "temperature",
          "unit": "Celsius",
          "dimension": "Temperature",
          "properties": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 525,
              "line": 14,
              "column": 3
            },
            "end": {
              "offset": 617,
              "line": 14,
              "column": 95
            }
          }
        }
      ],
      "location": {
        "source": {
          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
        },
        "start": {
          "offset": 21,
          "line": 2,
          "column": 1
        },
        "end": {
          "offset": 620,
          "line": 15,
          "column": 2
        }
      }
    },
    {
      "type": "Package",
      "name": "Ports",
      "appliedStyle": null,
      "imports": [
        "types"
      ],
      "importedDefinitions": [],
      "definitions": [
        {
          "type": "SimplePortDef",
          "name": "FTemperatureOPT",
          "flowProperties": "out",
          "flowType": "FahrenheitTemperature",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 652,
              "line": 16,
              "column": 32
            },
            "end": {
              "offset": 711,
              "line": 16,
              "column": 91
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "PresenceIPT",
          "flowProperties": "in",
          "flowType": "Boolean",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 714,
              "line": 17,
              "column": 3
            },
            "end": {
              "offset": 754,
              "line": 17,
              "column": 43
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "PresenceOPT",
          "flowProperties": "out",
          "flowType": "Boolean",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 757,
              "line": 18,
              "column": 3
            },
            "end": {
              "offset": 798,
              "line": 18,
              "column": 44
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "CTemperatureIPT",
          "flowProperties": "in",
          "flowType": "CelsiusTemperature",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 801,
              "line": 19,
              "column": 3
            },
            "end": {
              "offset": 856,
              "line": 19,
              "column": 58
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "CommandIPT",
          "flowProperties": "in",
          "flowType": "Command",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 859,
              "line": 20,
              "column": 3
            },
            "end": {
              "offset": 898,
              "line": 20,
              "column": 42
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "CommandOPT",
          "flowProperties": "out",
          "flowType": "Command",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 901,
              "line": 21,
              "column": 3
            },
            "end": {
              "offset": 941,
              "line": 21,
              "column": 43
            }
          }
        },
        {
          "type": "SimplePortDef",
          "name": "CTemperatureOPT",
          "flowProperties": "out",
          "flowType": "CelsiusTemperature",
          "arrayIndex": null,
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 944,
              "line": 22,
              "column": 3
            },
            "end": {
              "offset": 1000,
              "line": 22,
              "column": 59
            }
          }
        }
      ],
      "location": {
        "source": {
          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
        },
        "start": {
          "offset": 621,
          "line": 16,
          "column": 1
        },
        "end": {
          "offset": 1002,
          "line": 23,
          "column": 2
        }
      }
    },
    {
      "type": "Package",
      "name": "Connectors",
      "appliedStyle": null,
      "imports": [
        "types",
        "Ports"
      ],
      "importedDefinitions": [],
      "definitions": [
        {
          "type": "ConnectorDef",
          "name": "FahrenheitToCelsiusCN",
          "abstractConnector": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "Ft",
              "definition": "FTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1132,
                  "line": 29,
                  "column": 8
                },
                "end": {
                  "offset": 1154,
                  "line": 29,
                  "column": 30
                }
              },
              "isReverse": true
            },
            {
              "type": "PortUse",
              "name": "Ct",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1163,
                  "line": 30,
                  "column": 8
                },
                "end": {
                  "offset": 1185,
                  "line": 30,
                  "column": 30
                }
              },
              "isReverse": true
            }
          ],
          "composite": null,
          "flows": [
            {
              "type": "Flow",
              "flowType": "FahrenheitTemperature",
              "source": "Ft",
              "destination": "Ct",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1201,
                  "line": 32,
                  "column": 4
                },
                "end": {
                  "offset": 1240,
                  "line": 33,
                  "column": 4
                }
              }
            }
          ],
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 1066,
              "line": 27,
              "column": 4
            },
            "end": {
              "offset": 1241,
              "line": 33,
              "column": 5
            }
          }
        },
        {
          "type": "ConnectorDef",
          "name": "PresenceCN",
          "abstractConnector": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "pOut",
              "definition": "PresenceOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1299,
                  "line": 36,
                  "column": 8
                },
                "end": {
                  "offset": 1319,
                  "line": 36,
                  "column": 28
                }
              },
              "isReverse": true
            },
            {
              "type": "PortUse",
              "name": "pIn",
              "definition": "PresenceIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1328,
                  "line": 37,
                  "column": 8
                },
                "end": {
                  "offset": 1347,
                  "line": 37,
                  "column": 27
                }
              },
              "isReverse": true
            }
          ],
          "composite": null,
          "flows": [
            {
              "type": "Flow",
              "flowType": "Boolean",
              "source": "pOut",
              "destination": "pIn",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1367,
                  "line": 39,
                  "column": 6
                },
                "end": {
                  "offset": 1394,
                  "line": 40,
                  "column": 3
                }
              }
            }
          ],
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 1244,
              "line": 34,
              "column": 3
            },
            "end": {
              "offset": 1395,
              "line": 40,
              "column": 4
            }
          }
        },
        {
          "type": "ConnectorDef",
          "name": "CommandCN",
          "abstractConnector": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "commandOut",
              "definition": "CommandOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1452,
                  "line": 43,
                  "column": 8
                },
                "end": {
                  "offset": 1477,
                  "line": 43,
                  "column": 33
                }
              },
              "isReverse": true
            },
            {
              "type": "PortUse",
              "name": "commandIn",
              "definition": "CommandIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1486,
                  "line": 44,
                  "column": 8
                },
                "end": {
                  "offset": 1510,
                  "line": 44,
                  "column": 32
                }
              },
              "isReverse": true
            }
          ],
          "composite": null,
          "flows": [
            {
              "type": "Flow",
              "flowType": "Command",
              "source": "commandOut",
              "destination": "commandIn",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1530,
                  "line": 46,
                  "column": 6
                },
                "end": {
                  "offset": 1569,
                  "line": 47,
                  "column": 3
                }
              }
            }
          ],
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 1398,
              "line": 41,
              "column": 3
            },
            "end": {
              "offset": 1570,
              "line": 47,
              "column": 4
            }
          }
        },
        {
          "type": "ConnectorDef",
          "name": "CTemperatureCN",
          "abstractConnector": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "CtOut",
              "definition": "CTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1632,
                  "line": 50,
                  "column": 8
                },
                "end": {
                  "offset": 1657,
                  "line": 50,
                  "column": 33
                }
              },
              "isReverse": true
            },
            {
              "type": "PortUse",
              "name": "ctIn",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1666,
                  "line": 51,
                  "column": 8
                },
                "end": {
                  "offset": 1690,
                  "line": 51,
                  "column": 32
                }
              },
              "isReverse": true
            }
          ],
          "composite": null,
          "flows": [
            {
              "type": "Flow",
              "flowType": "CelsiusTemperature",
              "source": "CtOut",
              "destination": "ctIn",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 1710,
                  "line": 53,
                  "column": 6
                },
                "end": {
                  "offset": 1750,
                  "line": 54,
                  "column": 3
                }
              }
            }
          ],
          "members": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 1573,
              "line": 48,
              "column": 3
            },
            "end": {
              "offset": 1751,
              "line": 54,
              "column": 4
            }
          }
        }
      ],
      "location": {
        "source": {
          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
        },
        "start": {
          "offset": 1003,
          "line": 24,
          "column": 1
        },
        "end": {
          "offset": 1755,
          "line": 55,
          "column": 4
        }
      }
    },
    {
      "type": "Package",
      "name": "Components",
      "appliedStyle": null,
      "imports": [
        "Connectors",
        "types",
        "Ports"
      ],
      "importedDefinitions": [],
      "definitions": [
        {
          "type": "ComponentDef",
          "isBoundary": false,
          "name": "RTCSystemCFD",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [],
          "members": [],
          "composite": {
            "type": "Configuration",
            "components": [
              [],
              "components",
              [
                " "
              ],
              ":",
              [
                " ",
                "\n",
                "\t",
                "\t",
                " ",
                "\t",
                "\t"
              ],
              [
                {
                  "type": "ComponentUse",
                  "name": "s1",
                  "definition": "TemperatureSensorCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "current1",
                        "definition": "FTemperatureOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 1958,
                            "line": 63,
                            "column": 48
                          },
                          "end": {
                            "offset": 1986,
                            "line": 63,
                            "column": 76
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 1916,
                      "line": 63,
                      "column": 6
                    },
                    "end": {
                      "offset": 1988,
                      "line": 63,
                      "column": 78
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "s2",
                  "definition": "TemperatureSensorCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "current2",
                        "definition": "FTemperatureOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2037,
                            "line": 64,
                            "column": 49
                          },
                          "end": {
                            "offset": 2065,
                            "line": 64,
                            "column": 77
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 1995,
                      "line": 64,
                      "column": 7
                    },
                    "end": {
                      "offset": 2067,
                      "line": 64,
                      "column": 79
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "s3",
                  "definition": "PresenceSensorCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "detectedS",
                        "definition": "PresenceOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2111,
                            "line": 65,
                            "column": 44
                          },
                          "end": {
                            "offset": 2136,
                            "line": 65,
                            "column": 69
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2072,
                      "line": 65,
                      "column": 5
                    },
                    "end": {
                      "offset": 2138,
                      "line": 65,
                      "column": 71
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "ui",
                  "definition": "UserInterfaceCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "desired",
                        "definition": "CTemperatureOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2183,
                            "line": 66,
                            "column": 45
                          },
                          "end": {
                            "offset": 2210,
                            "line": 66,
                            "column": 72
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2145,
                      "line": 66,
                      "column": 7
                    },
                    "end": {
                      "offset": 2212,
                      "line": 66,
                      "column": 74
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "a2",
                  "definition": "CoolerCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "controllerC",
                        "definition": "CommandIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2250,
                            "line": 67,
                            "column": 38
                          },
                          "end": {
                            "offset": 2276,
                            "line": 67,
                            "column": 64
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2219,
                      "line": 67,
                      "column": 7
                    },
                    "end": {
                      "offset": 2278,
                      "line": 67,
                      "column": 66
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "a1",
                  "definition": "HeaterCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " "
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "controllerH",
                        "definition": "CommandIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2316,
                            "line": 68,
                            "column": 38
                          },
                          "end": {
                            "offset": 2342,
                            "line": 68,
                            "column": 64
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " "
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2285,
                      "line": 68,
                      "column": 7
                    },
                    "end": {
                      "offset": 2344,
                      "line": 68,
                      "column": 66
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "rtc",
                  "definition": "RoomTemperatureControllerCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " ",
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "detected",
                        "definition": "PresenceIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2419,
                            "line": 71,
                            "column": 9
                          },
                          "end": {
                            "offset": 2443,
                            "line": 71,
                            "column": 33
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "localtemp1",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2453,
                            "line": 72,
                            "column": 9
                          },
                          "end": {
                            "offset": 2483,
                            "line": 72,
                            "column": 39
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "localTemp2",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2493,
                            "line": 73,
                            "column": 9
                          },
                          "end": {
                            "offset": 2523,
                            "line": 73,
                            "column": 39
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "userTemp",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2533,
                            "line": 74,
                            "column": 9
                          },
                          "end": {
                            "offset": 2561,
                            "line": 74,
                            "column": 37
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "heating",
                        "definition": "CommandOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2571,
                            "line": 75,
                            "column": 9
                          },
                          "end": {
                            "offset": 2593,
                            "line": 75,
                            "column": 31
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "cooling",
                        "definition": "CommandOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 2603,
                            "line": 76,
                            "column": 9
                          },
                          "end": {
                            "offset": 2625,
                            "line": 76,
                            "column": 31
                          }
                        }
                      }
                    ],
                    [],
                    [
                      " ",
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2351,
                      "line": 69,
                      "column": 7
                    },
                    "end": {
                      "offset": 2634,
                      "line": 77,
                      "column": 8
                    }
                  }
                }
              ]
            ],
            "connectors": [
              [
                "\n",
                "\t",
                " ",
                " ",
                "\t",
                "\t"
              ],
              "connectors",
              [
                " "
              ],
              ":",
              [
                " ",
                "\n",
                "\t",
                " ",
                " ",
                "\t",
                "\t",
                "\t"
              ],
              [
                {
                  "type": "ConnectorUse",
                  "name": "c1",
                  "definition": "FahrenheitToCelsiusCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "current1",
                          "destination": "localtemp1",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2696,
                              "line": 79,
                              "column": 43
                            },
                            "end": {
                              "offset": 2717,
                              "line": 79,
                              "column": 64
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2696,
                          "line": 79,
                          "column": 43
                        },
                        "end": {
                          "offset": 2717,
                          "line": 79,
                          "column": 64
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2660,
                      "line": 79,
                      "column": 7
                    },
                    "end": {
                      "offset": 2719,
                      "line": 79,
                      "column": 66
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "uc",
                  "definition": "CTemperatureCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "desired",
                          "destination": "userTemp",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2756,
                              "line": 80,
                              "column": 36
                            },
                            "end": {
                              "offset": 2774,
                              "line": 80,
                              "column": 54
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2756,
                          "line": 80,
                          "column": 36
                        },
                        "end": {
                          "offset": 2774,
                          "line": 80,
                          "column": 54
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2727,
                      "line": 80,
                      "column": 7
                    },
                    "end": {
                      "offset": 2776,
                      "line": 80,
                      "column": 56
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "cc2",
                  "definition": "CommandCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "cooling",
                          "destination": "controllerC",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2809,
                              "line": 81,
                              "column": 32
                            },
                            "end": {
                              "offset": 2830,
                              "line": 81,
                              "column": 53
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2809,
                          "line": 81,
                          "column": 32
                        },
                        "end": {
                          "offset": 2830,
                          "line": 81,
                          "column": 53
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2784,
                      "line": 81,
                      "column": 7
                    },
                    "end": {
                      "offset": 2832,
                      "line": 81,
                      "column": 55
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "pc",
                  "definition": "PresenceCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "detectedS",
                          "destination": "detected",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2865,
                              "line": 82,
                              "column": 32
                            },
                            "end": {
                              "offset": 2885,
                              "line": 82,
                              "column": 52
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2865,
                          "line": 82,
                          "column": 32
                        },
                        "end": {
                          "offset": 2885,
                          "line": 82,
                          "column": 52
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2840,
                      "line": 82,
                      "column": 7
                    },
                    "end": {
                      "offset": 2887,
                      "line": 82,
                      "column": 54
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "c2",
                  "definition": "FahrenheitToCelsiusCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "current2",
                          "destination": "localTemp2",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2931,
                              "line": 83,
                              "column": 43
                            },
                            "end": {
                              "offset": 2952,
                              "line": 83,
                              "column": 64
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2931,
                          "line": 83,
                          "column": 43
                        },
                        "end": {
                          "offset": 2952,
                          "line": 83,
                          "column": 64
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2895,
                      "line": 83,
                      "column": 7
                    },
                    "end": {
                      "offset": 2954,
                      "line": 83,
                      "column": 66
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "cc1",
                  "definition": "CommandCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "heating",
                          "destination": "controllerH",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 2987,
                              "line": 84,
                              "column": 32
                            },
                            "end": {
                              "offset": 3008,
                              "line": 84,
                              "column": 53
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 2987,
                          "line": 84,
                          "column": 32
                        },
                        "end": {
                          "offset": 3008,
                          "line": 84,
                          "column": 53
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 2962,
                      "line": 84,
                      "column": 7
                    },
                    "end": {
                      "offset": 3010,
                      "line": 84,
                      "column": 55
                    }
                  }
                }
              ]
            ],
            "delegations": [],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 1875,
                "line": 61,
                "column": 4
              },
              "end": {
                "offset": 3021,
                "line": 86,
                "column": 4
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 1842,
              "line": 60,
              "column": 2
            },
            "end": {
              "offset": 3022,
              "line": 86,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": false,
          "name": "RoomTemperatureControllerCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "detectedRTC",
              "definition": "PresenceIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3081,
                  "line": 89,
                  "column": 11
                },
                "end": {
                  "offset": 3108,
                  "line": 89,
                  "column": 38
                }
              }
            },
            {
              "type": "PortUse",
              "name": "localtemp1",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3109,
                  "line": 89,
                  "column": 39
                },
                "end": {
                  "offset": 3139,
                  "line": 89,
                  "column": 69
                }
              }
            },
            {
              "type": "PortUse",
              "name": "localTemp2",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3140,
                  "line": 89,
                  "column": 70
                },
                "end": {
                  "offset": 3170,
                  "line": 89,
                  "column": 100
                }
              }
            },
            {
              "type": "PortUse",
              "name": "userTempRTC",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3171,
                  "line": 89,
                  "column": 101
                },
                "end": {
                  "offset": 3202,
                  "line": 89,
                  "column": 132
                }
              }
            },
            {
              "type": "PortUse",
              "name": "heatingRTC",
              "definition": "CommandOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3203,
                  "line": 89,
                  "column": 133
                },
                "end": {
                  "offset": 3228,
                  "line": 89,
                  "column": 158
                }
              }
            },
            {
              "type": "PortUse",
              "name": "coolingRTC",
              "definition": "CommandOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 3229,
                  "line": 89,
                  "column": 159
                },
                "end": {
                  "offset": 3254,
                  "line": 89,
                  "column": 184
                }
              }
            }
          ],
          "members": [],
          "composite": {
            "type": "Configuration",
            "components": [
              [],
              "components",
              [
                " "
              ],
              ":",
              [
                " ",
                "\n",
                "\t",
                "\t",
                "\t",
                "\t"
              ],
              [
                {
                  "type": "ComponentUse",
                  "name": "sm",
                  "definition": "SensorsMonitorCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " ",
                      "\n",
                      "\t",
                      "\t",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "s1",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3342,
                            "line": 93,
                            "column": 20
                          },
                          "end": {
                            "offset": 3364,
                            "line": 93,
                            "column": 42
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "s2",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3372,
                            "line": 94,
                            "column": 7
                          },
                          "end": {
                            "offset": 3394,
                            "line": 94,
                            "column": 29
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "average",
                        "definition": "CTemperatureOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3402,
                            "line": 95,
                            "column": 7
                          },
                          "end": {
                            "offset": 3429,
                            "line": 95,
                            "column": 34
                          }
                        }
                      }
                    ],
                    [],
                    [
                      "\n",
                      "\t",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3297,
                      "line": 92,
                      "column": 5
                    },
                    "end": {
                      "offset": 3435,
                      "line": 96,
                      "column": 6
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "cm",
                  "definition": "CommanderCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " ",
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "target2",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3493,
                            "line": 99,
                            "column": 9
                          },
                          "end": {
                            "offset": 3520,
                            "line": 99,
                            "column": 36
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "average2",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3530,
                            "line": 100,
                            "column": 9
                          },
                          "end": {
                            "offset": 3558,
                            "line": 100,
                            "column": 37
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "heating",
                        "definition": "CommandOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3568,
                            "line": 101,
                            "column": 9
                          },
                          "end": {
                            "offset": 3590,
                            "line": 101,
                            "column": 31
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "cooling",
                        "definition": "CommandOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3600,
                            "line": 102,
                            "column": 9
                          },
                          "end": {
                            "offset": 3622,
                            "line": 102,
                            "column": 31
                          }
                        }
                      }
                    ],
                    [],
                    [
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3442,
                      "line": 97,
                      "column": 7
                    },
                    "end": {
                      "offset": 3630,
                      "line": 103,
                      "column": 8
                    }
                  }
                },
                {
                  "type": "ComponentUse",
                  "name": "pc",
                  "definition": "PresenceCheckerCP",
                  "bounds": null,
                  "body": [
                    "{",
                    [
                      "\t",
                      " ",
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    [
                      {
                        "type": "PortUse",
                        "name": "detected",
                        "definition": "PresenceIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3694,
                            "line": 106,
                            "column": 9
                          },
                          "end": {
                            "offset": 3718,
                            "line": 106,
                            "column": 33
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "userTemp",
                        "definition": "CTemperatureIPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3728,
                            "line": 107,
                            "column": 9
                          },
                          "end": {
                            "offset": 3756,
                            "line": 107,
                            "column": 37
                          }
                        }
                      },
                      {
                        "type": "PortUse",
                        "name": "target",
                        "definition": "CTemperatureOPT",
                        "concrete": null,
                        "bounds": null,
                        "body": ";",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 3766,
                            "line": 108,
                            "column": 9
                          },
                          "end": {
                            "offset": 3792,
                            "line": 108,
                            "column": 35
                          }
                        }
                      }
                    ],
                    [],
                    [
                      "\n",
                      "\t",
                      " ",
                      " ",
                      "\t",
                      "\t",
                      "\t"
                    ],
                    "}"
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3637,
                      "line": 104,
                      "column": 7
                    },
                    "end": {
                      "offset": 3800,
                      "line": 109,
                      "column": 8
                    }
                  }
                }
              ]
            ],
            "connectors": [
              [
                "\n",
                "\t",
                " ",
                " ",
                "\t",
                "\t"
              ],
              "connectors",
              [
                " "
              ],
              ":",
              [
                " ",
                "\n",
                "\t",
                " ",
                " ",
                "\t",
                "\t",
                "\t"
              ],
              [
                {
                  "type": "ConnectorUse",
                  "name": "target",
                  "definition": "CTemperatureCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "target",
                          "destination": "target2",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 3859,
                              "line": 111,
                              "column": 40
                            },
                            "end": {
                              "offset": 3875,
                              "line": 111,
                              "column": 56
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 3859,
                          "line": 111,
                          "column": 40
                        },
                        "end": {
                          "offset": 3875,
                          "line": 111,
                          "column": 56
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3826,
                      "line": 111,
                      "column": 7
                    },
                    "end": {
                      "offset": 3877,
                      "line": 111,
                      "column": 58
                    }
                  }
                },
                {
                  "type": "ConnectorUse",
                  "name": "average",
                  "definition": "CTemperatureCN",
                  "bounds": null,
                  "bindings": [
                    "bindings",
                    [
                      " "
                    ],
                    {
                      "type": "ConnectorBindingList",
                      "items": [
                        {
                          "type": "ConnectorBinding",
                          "source": "average",
                          "destination": "average2",
                          "location": {
                            "source": {
                              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                            },
                            "start": {
                              "offset": 3919,
                              "line": 112,
                              "column": 41
                            },
                            "end": {
                              "offset": 3937,
                              "line": 112,
                              "column": 59
                            }
                          }
                        }
                      ],
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 3919,
                          "line": 112,
                          "column": 41
                        },
                        "end": {
                          "offset": 3937,
                          "line": 112,
                          "column": 59
                        }
                      }
                    }
                  ],
                  "body": ";",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3885,
                      "line": 112,
                      "column": 7
                    },
                    "end": {
                      "offset": 3939,
                      "line": 112,
                      "column": 61
                    }
                  }
                }
              ]
            ],
            "delegations": [
              [
                " ",
                "\n",
                " ",
                " ",
                "\t",
                "\t",
                "\t"
              ],
              "delegations",
              [
                " "
              ],
              ":",
              [
                "\n",
                " ",
                " ",
                "\t",
                "\t",
                "\t",
                "\t"
              ],
              [
                {
                  "type": "Delegation",
                  "source": "userTemp",
                  "destination": "userTempRTC",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3966,
                      "line": 114,
                      "column": 7
                    },
                    "end": {
                      "offset": 3997,
                      "line": 115,
                      "column": 7
                    }
                  }
                },
                {
                  "type": "Delegation",
                  "source": "detected",
                  "destination": "detectedRTC",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 3997,
                      "line": 115,
                      "column": 7
                    },
                    "end": {
                      "offset": 4028,
                      "line": 116,
                      "column": 7
                    }
                  }
                },
                {
                  "type": "Delegation",
                  "source": "s1",
                  "destination": "localtemp1",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 4028,
                      "line": 116,
                      "column": 7
                    },
                    "end": {
                      "offset": 4052,
                      "line": 117,
                      "column": 7
                    }
                  }
                },
                {
                  "type": "Delegation",
                  "source": "s2",
                  "destination": "localTemp2",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 4052,
                      "line": 117,
                      "column": 7
                    },
                    "end": {
                      "offset": 4076,
                      "line": 118,
                      "column": 7
                    }
                  }
                },
                {
                  "type": "Delegation",
                  "source": "heating",
                  "destination": "heatingRTC",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 4076,
                      "line": 118,
                      "column": 7
                    },
                    "end": {
                      "offset": 4105,
                      "line": 119,
                      "column": 7
                    }
                  }
                },
                {
                  "type": "Delegation",
                  "source": "cooling",
                  "destination": "coolingRTC",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 4105,
                      "line": 119,
                      "column": 7
                    },
                    "end": {
                      "offset": 4132,
                      "line": 120,
                      "column": 5
                    }
                  }
                }
              ]
            ],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 3258,
                "line": 90,
                "column": 3
              },
              "end": {
                "offset": 4137,
                "line": 121,
                "column": 4
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 3025,
              "line": 88,
              "column": 2
            },
            "end": {
              "offset": 4138,
              "line": 121,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": true,
          "name": "TemperatureSensorCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "current",
              "definition": "FTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4201,
                  "line": 123,
                  "column": 14
                },
                "end": {
                  "offset": 4228,
                  "line": 123,
                  "column": 41
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4141,
              "line": 122,
              "column": 2
            },
            "end": {
              "offset": 4233,
              "line": 124,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": true,
          "name": "PresenceSensorCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "detected",
              "definition": "PresenceOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4293,
                  "line": 126,
                  "column": 14
                },
                "end": {
                  "offset": 4317,
                  "line": 126,
                  "column": 38
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4236,
              "line": 125,
              "column": 2
            },
            "end": {
              "offset": 4322,
              "line": 127,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": true,
          "name": "UserInterfaceCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "desired",
              "definition": "CTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4381,
                  "line": 129,
                  "column": 14
                },
                "end": {
                  "offset": 4408,
                  "line": 129,
                  "column": 41
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4325,
              "line": 128,
              "column": 2
            },
            "end": {
              "offset": 4413,
              "line": 130,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": true,
          "name": "HeaterCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "controllerH",
              "definition": "CommandIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4465,
                  "line": 132,
                  "column": 14
                },
                "end": {
                  "offset": 4491,
                  "line": 132,
                  "column": 40
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4416,
              "line": 131,
              "column": 2
            },
            "end": {
              "offset": 4496,
              "line": 133,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": true,
          "name": "CoolerCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "controllerC",
              "definition": "CommandIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4548,
                  "line": 135,
                  "column": 14
                },
                "end": {
                  "offset": 4574,
                  "line": 135,
                  "column": 40
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4499,
              "line": 134,
              "column": 2
            },
            "end": {
              "offset": 4579,
              "line": 136,
              "column": 5
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": false,
          "name": "PresenceCheckerCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "detected",
              "definition": "PresenceIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4627,
                  "line": 138,
                  "column": 11
                },
                "end": {
                  "offset": 4651,
                  "line": 138,
                  "column": 35
                }
              }
            },
            {
              "type": "PortUse",
              "name": "userTemp",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4652,
                  "line": 138,
                  "column": 36
                },
                "end": {
                  "offset": 4680,
                  "line": 138,
                  "column": 64
                }
              }
            },
            {
              "type": "PortUse",
              "name": "target",
              "definition": "CTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4681,
                  "line": 138,
                  "column": 65
                },
                "end": {
                  "offset": 4707,
                  "line": 138,
                  "column": 91
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4581,
              "line": 137,
              "column": 2
            },
            "end": {
              "offset": 4710,
              "line": 139,
              "column": 3
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": false,
          "name": "CommanderCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "target2",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4753,
                  "line": 142,
                  "column": 11
                },
                "end": {
                  "offset": 4780,
                  "line": 142,
                  "column": 38
                }
              }
            },
            {
              "type": "PortUse",
              "name": "average2",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4781,
                  "line": 142,
                  "column": 39
                },
                "end": {
                  "offset": 4809,
                  "line": 142,
                  "column": 67
                }
              }
            },
            {
              "type": "PortUse",
              "name": "heating",
              "definition": "CommandOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4810,
                  "line": 142,
                  "column": 68
                },
                "end": {
                  "offset": 4832,
                  "line": 142,
                  "column": 90
                }
              }
            },
            {
              "type": "PortUse",
              "name": "cooling",
              "definition": "CommandOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4833,
                  "line": 142,
                  "column": 91
                },
                "end": {
                  "offset": 4855,
                  "line": 142,
                  "column": 113
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4713,
              "line": 141,
              "column": 2
            },
            "end": {
              "offset": 4858,
              "line": 143,
              "column": 3
            }
          }
        },
        {
          "type": "ComponentDef",
          "isBoundary": false,
          "name": "SensorsMonitorCP",
          "appliedStyle": null,
          "abstractComponent": null,
          "ports": [
            {
              "type": "PortUse",
              "name": "s1",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4905,
                  "line": 146,
                  "column": 11
                },
                "end": {
                  "offset": 4927,
                  "line": 146,
                  "column": 33
                }
              }
            },
            {
              "type": "PortUse",
              "name": "s2",
              "definition": "CTemperatureIPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4928,
                  "line": 146,
                  "column": 34
                },
                "end": {
                  "offset": 4950,
                  "line": 146,
                  "column": 56
                }
              }
            },
            {
              "type": "PortUse",
              "name": "average",
              "definition": "CTemperatureOPT",
              "concrete": null,
              "bounds": null,
              "body": ";",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 4951,
                  "line": 146,
                  "column": 57
                },
                "end": {
                  "offset": 4978,
                  "line": 146,
                  "column": 84
                }
              }
            }
          ],
          "members": [],
          "composite": null,
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4861,
              "line": 145,
              "column": 2
            },
            "end": {
              "offset": 4981,
              "line": 147,
              "column": 3
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "CalculateAverageTemperatureEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "t1",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5028,
                    "line": 149,
                    "column": 45
                  },
                  "end": {
                    "offset": 5052,
                    "line": 149,
                    "column": 69
                  }
                }
              },
              {
                "type": "Pin",
                "name": "t2",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5054,
                    "line": 149,
                    "column": 71
                  },
                  "end": {
                    "offset": 5078,
                    "line": 149,
                    "column": 95
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "av",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5084,
                    "line": 149,
                    "column": 101
                  },
                  "end": {
                    "offset": 5108,
                    "line": 149,
                    "column": 125
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "BinaryExpression",
              "operator": "==",
              "left": {
                "type": "NameExpression",
                "name": "av",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5125,
                    "line": 150,
                    "column": 14
                  },
                  "end": {
                    "offset": 5127,
                    "line": 150,
                    "column": 16
                  }
                }
              },
              "right": {
                "type": "BinaryExpression",
                "operator": "/",
                "left": {
                  "type": "BinaryExpression",
                  "operator": "+",
                  "left": {
                    "type": "NameExpression",
                    "name": "t1",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 5132,
                        "line": 150,
                        "column": 21
                      },
                      "end": {
                        "offset": 5134,
                        "line": 150,
                        "column": 23
                      }
                    }
                  },
                  "right": {
                    "type": "NameExpression",
                    "name": "t2",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 5137,
                        "line": 150,
                        "column": 26
                      },
                      "end": {
                        "offset": 5139,
                        "line": 150,
                        "column": 28
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 5132,
                      "line": 150,
                      "column": 21
                    },
                    "end": {
                      "offset": 5139,
                      "line": 150,
                      "column": 28
                    }
                  }
                },
                "right": {
                  "type": "NaturalLiteral",
                  "value": 2,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 5141,
                      "line": 150,
                      "column": 30
                    },
                    "end": {
                      "offset": 5142,
                      "line": 150,
                      "column": 31
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5131,
                    "line": 150,
                    "column": 20
                  },
                  "end": {
                    "offset": 5142,
                    "line": 150,
                    "column": 31
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5125,
                  "line": 150,
                  "column": 14
                },
                "end": {
                  "offset": 5144,
                  "line": 151,
                  "column": 2
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 4985,
              "line": 149,
              "column": 2
            },
            "end": {
              "offset": 5145,
              "line": 151,
              "column": 3
            }
          }
        },
        {
          "type": "ActivityDef",
          "name": "CalculateAverageTemperatureAC",
          "implements": [],
          "inParameters": [
            [
              {
                "type": "Pin",
                "name": "s1",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5193,
                    "line": 152,
                    "column": 47
                  },
                  "end": {
                    "offset": 5217,
                    "line": 152,
                    "column": 71
                  }
                }
              }
            ],
            [
              {
                "type": "Pin",
                "name": "s2",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5221,
                    "line": 152,
                    "column": 75
                  },
                  "end": {
                    "offset": 5245,
                    "line": 152,
                    "column": 99
                  }
                }
              }
            ]
          ],
          "outParameters": [
            {
              "type": "Pin",
              "name": "average",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5251,
                  "line": 152,
                  "column": 105
                },
                "end": {
                  "offset": 5280,
                  "line": 152,
                  "column": 134
                }
              }
            }
          ],
          "body": {
            "type": "ActivityBody",
            "actions": [
              [
                "CalcAvTemp",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "CalculateAverageTemperatureAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "CalcAvTemp",
                  "definition": "CalculateAverageTemperatureAN",
                  "using": [
                    {
                      "name": "s1",
                      "type": "CelsiusTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 5371,
                          "line": 155,
                          "column": 18
                        },
                        "end": {
                          "offset": 5402,
                          "line": 156,
                          "column": 5
                        }
                      }
                    },
                    {
                      "name": "s2",
                      "type": "CelsiusTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 5402,
                          "line": 156,
                          "column": 5
                        },
                        "end": {
                          "offset": 5431,
                          "line": 157,
                          "column": 4
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 5351,
                      "line": 154,
                      "column": 57
                    },
                    "end": {
                      "offset": 5437,
                      "line": 158,
                      "column": 4
                    }
                  }
                }
              ]
            ],
            "relations": [
              {
                "type": "ActivityDelegation",
                "source": "s1",
                "target": "s1",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5437,
                    "line": 158,
                    "column": 4
                  },
                  "end": {
                    "offset": 5459,
                    "line": 159,
                    "column": 4
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "s2",
                "target": "s2",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5459,
                    "line": 159,
                    "column": 4
                  },
                  "end": {
                    "offset": 5481,
                    "line": 160,
                    "column": 4
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "average",
                "target": "CalcAvTemp",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5481,
                    "line": 160,
                    "column": 4
                  },
                  "end": {
                    "offset": 5514,
                    "line": 161,
                    "column": 3
                  }
                }
              }
            ],
            "dataObjects": [],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 5287,
                "line": 153,
                "column": 3
              },
              "end": {
                "offset": 5515,
                "line": 161,
                "column": 4
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 5148,
              "line": 152,
              "column": 2
            },
            "end": {
              "offset": 5518,
              "line": 162,
              "column": 3
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "CalculateAverageTemperatureAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "t1",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5564,
                  "line": 163,
                  "column": 45
                },
                "end": {
                  "offset": 5588,
                  "line": 163,
                  "column": 69
                }
              }
            },
            {
              "type": "Pin",
              "name": "t2",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5590,
                  "line": 163,
                  "column": 71
                },
                "end": {
                  "offset": 5614,
                  "line": 163,
                  "column": 95
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "CalculateAverageTemperatureEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5655,
                  "line": 164,
                  "column": 16
                },
                "end": {
                  "offset": 5699,
                  "line": 164,
                  "column": 60
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 5521,
              "line": 163,
              "column": 2
            },
            "end": {
              "offset": 5702,
              "line": 165,
              "column": 3
            }
          }
        },
        {
          "type": "ActivityDef",
          "name": "CheckPresenceToSetTemperatureAC",
          "implements": [],
          "inParameters": [
            [
              {
                "type": "Pin",
                "name": "detected",
                "isFlow": false,
                "definition": "Boolean",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5752,
                    "line": 166,
                    "column": 49
                  },
                  "end": {
                    "offset": 5771,
                    "line": 166,
                    "column": 68
                  }
                }
              }
            ],
            [
              {
                "type": "Pin",
                "name": "userTemp",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 5775,
                    "line": 166,
                    "column": 72
                  },
                  "end": {
                    "offset": 5805,
                    "line": 166,
                    "column": 102
                  }
                }
              }
            ]
          ],
          "outParameters": [
            {
              "type": "Pin",
              "name": "target",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 5811,
                  "line": 166,
                  "column": 108
                },
                "end": {
                  "offset": 5839,
                  "line": 166,
                  "column": 136
                }
              }
            }
          ],
          "body": {
            "type": "ActivityBody",
            "actions": [
              [
                "CheckPeresenceToSetTemperatureAN",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "CheckPeresenceToSetTemperatureAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "CheckPeresenceToSetTemperatureAN",
                  "definition": "CheckPeresenceToSetTemperatureAN",
                  "using": [
                    {
                      "name": "detected",
                      "type": "Boolean",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 5961,
                          "line": 170,
                          "column": 6
                        },
                        "end": {
                          "offset": 5988,
                          "line": 171,
                          "column": 6
                        }
                      }
                    },
                    {
                      "name": "userTemp",
                      "type": "CelsiusTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 5988,
                          "line": 171,
                          "column": 6
                        },
                        "end": {
                          "offset": 6023,
                          "line": 172,
                          "column": 4
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 5935,
                      "line": 168,
                      "column": 82
                    },
                    "end": {
                      "offset": 6029,
                      "line": 173,
                      "column": 4
                    }
                  }
                }
              ]
            ],
            "relations": [
              {
                "type": "ActivityDelegation",
                "source": "detected",
                "target": "detected",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6029,
                    "line": 173,
                    "column": 4
                  },
                  "end": {
                    "offset": 6063,
                    "line": 174,
                    "column": 4
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "userTemp",
                "target": "userTemp",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6063,
                    "line": 174,
                    "column": 4
                  },
                  "end": {
                    "offset": 6097,
                    "line": 175,
                    "column": 4
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "target",
                "target": "CheckPeresenceToSetTemperatureAN",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6097,
                    "line": 175,
                    "column": 4
                  },
                  "end": {
                    "offset": 6151,
                    "line": 176,
                    "column": 3
                  }
                }
              }
            ],
            "dataObjects": [],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 5846,
                "line": 167,
                "column": 3
              },
              "end": {
                "offset": 6152,
                "line": 176,
                "column": 4
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 5705,
              "line": 166,
              "column": 2
            },
            "end": {
              "offset": 6155,
              "line": 177,
              "column": 3
            }
          }
        },
        {
          "type": "ActivityDef",
          "name": "DecideCommandAC",
          "implements": [],
          "inParameters": [
            [
              {
                "type": "Pin",
                "name": "average2",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6189,
                    "line": 178,
                    "column": 33
                  },
                  "end": {
                    "offset": 6219,
                    "line": 178,
                    "column": 63
                  }
                }
              }
            ],
            [
              {
                "type": "Pin",
                "name": "target2",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6223,
                    "line": 178,
                    "column": 67
                  },
                  "end": {
                    "offset": 6252,
                    "line": 178,
                    "column": 96
                  }
                }
              }
            ]
          ],
          "outParameters": [
            {
              "type": "Pin",
              "name": "cooling",
              "isFlow": false,
              "definition": "Command",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 6258,
                  "line": 178,
                  "column": 102
                },
                "end": {
                  "offset": 6276,
                  "line": 178,
                  "column": 120
                }
              }
            },
            {
              "type": "Pin",
              "name": "heating",
              "isFlow": false,
              "definition": "Command",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 6278,
                  "line": 178,
                  "column": 122
                },
                "end": {
                  "offset": 6296,
                  "line": 178,
                  "column": 140
                }
              }
            }
          ],
          "body": {
            "type": "ActivityBody",
            "actions": [
              [
                "ct",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "CompareTemperatureAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "ct",
                  "definition": "CompareTemperatureAN",
                  "using": [
                    {
                      "name": "average2",
                      "type": "CelsiusTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 6365,
                          "line": 180,
                          "column": 55
                        },
                        "end": {
                          "offset": 6397,
                          "line": 180,
                          "column": 87
                        }
                      }
                    },
                    {
                      "name": "target2",
                      "type": "CelsiusTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 6397,
                          "line": 180,
                          "column": 87
                        },
                        "end": {
                          "offset": 6428,
                          "line": 180,
                          "column": 118
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 6350,
                      "line": 180,
                      "column": 40
                    },
                    "end": {
                      "offset": 6430,
                      "line": 180,
                      "column": 120
                    }
                  }
                }
              ],
              [
                "cmdH",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "CommandHeaterAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "cmdH",
                  "definition": "CommandHeaterAN",
                  "using": [
                    {
                      "name": "cmdsH",
                      "type": "Commands",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 6468,
                          "line": 180,
                          "column": 158
                        },
                        "end": {
                          "offset": 6487,
                          "line": 180,
                          "column": 177
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 6453,
                      "line": 180,
                      "column": 143
                    },
                    "end": {
                      "offset": 6489,
                      "line": 180,
                      "column": 179
                    }
                  }
                }
              ],
              [
                "cmdC",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "CommandCoolerAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "cmdC",
                  "definition": "CommandCoolerAN",
                  "using": [
                    {
                      "name": "cmdsC",
                      "type": "Commands",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 6527,
                          "line": 180,
                          "column": 217
                        },
                        "end": {
                          "offset": 6546,
                          "line": 180,
                          "column": 236
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 6512,
                      "line": 180,
                      "column": 202
                    },
                    "end": {
                      "offset": 6548,
                      "line": 180,
                      "column": 238
                    }
                  }
                }
              ]
            ],
            "relations": [
              {
                "type": "ActivityDelegation",
                "source": "average2",
                "target": "average2",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6548,
                    "line": 180,
                    "column": 238
                  },
                  "end": {
                    "offset": 6578,
                    "line": 180,
                    "column": 268
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "target2",
                "target": "target2",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6578,
                    "line": 180,
                    "column": 268
                  },
                  "end": {
                    "offset": 6606,
                    "line": 180,
                    "column": 296
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "heating",
                "target": "cmdH",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6606,
                    "line": 180,
                    "column": 296
                  },
                  "end": {
                    "offset": 6631,
                    "line": 180,
                    "column": 321
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "cooling",
                "target": "cmdC",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6631,
                    "line": 180,
                    "column": 321
                  },
                  "end": {
                    "offset": 6656,
                    "line": 180,
                    "column": 346
                  }
                }
              },
              {
                "type": "ActivityFlow",
                "source": "ct",
                "target": "cmdsH",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6656,
                    "line": 180,
                    "column": 346
                  },
                  "end": {
                    "offset": 6678,
                    "line": 180,
                    "column": 368
                  }
                }
              },
              {
                "type": "ActivityFlow",
                "source": "ct",
                "target": "cmdsC",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6678,
                    "line": 180,
                    "column": 368
                  },
                  "end": {
                    "offset": 6702,
                    "line": 181,
                    "column": 3
                  }
                }
              }
            ],
            "dataObjects": [],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 6303,
                "line": 179,
                "column": 3
              },
              "end": {
                "offset": 6703,
                "line": 181,
                "column": 4
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 6158,
              "line": 178,
              "column": 2
            },
            "end": {
              "offset": 6706,
              "line": 182,
              "column": 3
            }
          }
        },
        {
          "type": "ActivityDef",
          "name": "FahrenheitToCelsiusAC",
          "implements": [],
          "inParameters": [
            [
              {
                "type": "Pin",
                "name": "current1",
                "isFlow": false,
                "definition": "FahrenheitTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6746,
                    "line": 183,
                    "column": 39
                  },
                  "end": {
                    "offset": 6779,
                    "line": 183,
                    "column": 72
                  }
                }
              }
            ]
          ],
          "outParameters": [
            {
              "type": "Pin",
              "name": "loalTemp1",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 6785,
                  "line": 183,
                  "column": 78
                },
                "end": {
                  "offset": 6816,
                  "line": 183,
                  "column": 109
                }
              }
            }
          ],
          "body": {
            "type": "ActivityBody",
            "actions": [
              [
                "FtC",
                [
                  " "
                ],
                ":",
                [
                  " "
                ],
                "FahrenheitToCelsiusAN",
                [
                  " "
                ],
                {
                  "type": "ActionUse",
                  "name": "FtC",
                  "definition": "FahrenheitToCelsiusAN",
                  "using": [
                    {
                      "name": "current1",
                      "type": "FahrenheitTemperature",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 6883,
                          "line": 184,
                          "column": 63
                        },
                        "end": {
                          "offset": 6918,
                          "line": 184,
                          "column": 98
                        }
                      }
                    }
                  ],
                  "properties": [],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 6868,
                      "line": 184,
                      "column": 48
                    },
                    "end": {
                      "offset": 6920,
                      "line": 184,
                      "column": 100
                    }
                  }
                }
              ]
            ],
            "relations": [
              {
                "type": "ActivityDelegation",
                "source": "loalTemp1",
                "target": "FtC",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6920,
                    "line": 184,
                    "column": 100
                  },
                  "end": {
                    "offset": 6946,
                    "line": 184,
                    "column": 126
                  }
                }
              },
              {
                "type": "ActivityDelegation",
                "source": "current1",
                "target": "current1",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 6946,
                    "line": 184,
                    "column": 126
                  },
                  "end": {
                    "offset": 6976,
                    "line": 184,
                    "column": 156
                  }
                }
              }
            ],
            "dataObjects": [],
            "location": {
              "source": {
                "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
              },
              "start": {
                "offset": 6823,
                "line": 184,
                "column": 3
              },
              "end": {
                "offset": 6977,
                "line": 184,
                "column": 157
              }
            }
          },
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 6709,
              "line": 183,
              "column": 2
            },
            "end": {
              "offset": 6980,
              "line": 185,
              "column": 3
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "CompareTemperatureAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "average2",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7016,
                  "line": 186,
                  "column": 35
                },
                "end": {
                  "offset": 7046,
                  "line": 186,
                  "column": 65
                }
              }
            },
            {
              "type": "Pin",
              "name": "target2",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7048,
                  "line": 186,
                  "column": 67
                },
                "end": {
                  "offset": 7076,
                  "line": 186,
                  "column": 95
                }
              }
            }
          ],
          "returnType": "Commands",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "CompareTemperatureEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7111,
                  "line": 188,
                  "column": 17
                },
                "end": {
                  "offset": 7146,
                  "line": 188,
                  "column": 52
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 6983,
              "line": 186,
              "column": 2
            },
            "end": {
              "offset": 7151,
              "line": 189,
              "column": 4
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "CommandHeaterAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "cmds",
              "isFlow": false,
              "definition": "Commands",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7183,
                  "line": 190,
                  "column": 31
                },
                "end": {
                  "offset": 7199,
                  "line": 190,
                  "column": 47
                }
              }
            }
          ],
          "returnType": "Command",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "CommandHeaterEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7233,
                  "line": 192,
                  "column": 17
                },
                "end": {
                  "offset": 7263,
                  "line": 192,
                  "column": 47
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7154,
              "line": 190,
              "column": 2
            },
            "end": {
              "offset": 7267,
              "line": 193,
              "column": 4
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "CommandCoolerAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "cmds",
              "isFlow": false,
              "definition": "Commands",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7299,
                  "line": 194,
                  "column": 31
                },
                "end": {
                  "offset": 7315,
                  "line": 194,
                  "column": 47
                }
              }
            }
          ],
          "returnType": "Command",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "CommandCoolerEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7349,
                  "line": 196,
                  "column": 17
                },
                "end": {
                  "offset": 7379,
                  "line": 196,
                  "column": 47
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7270,
              "line": 194,
              "column": 2
            },
            "end": {
              "offset": 7383,
              "line": 197,
              "column": 4
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "CompareTemperatureEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "target",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7420,
                    "line": 198,
                    "column": 36
                  },
                  "end": {
                    "offset": 7448,
                    "line": 198,
                    "column": 64
                  }
                }
              },
              {
                "type": "Pin",
                "name": "average",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7450,
                    "line": 198,
                    "column": 66
                  },
                  "end": {
                    "offset": 7479,
                    "line": 198,
                    "column": 95
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "cmds",
                "isFlow": false,
                "definition": "Commands",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7488,
                    "line": 199,
                    "column": 7
                  },
                  "end": {
                    "offset": 7504,
                    "line": 199,
                    "column": 23
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "ConditionalExpression",
              "condition": {
                "type": "BinaryExpression",
                "operator": ">",
                "left": {
                  "type": "NameExpression",
                  "name": "average",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7523,
                      "line": 200,
                      "column": 15
                    },
                    "end": {
                      "offset": 7530,
                      "line": 200,
                      "column": 22
                    }
                  }
                },
                "right": {
                  "type": "NameExpression",
                  "name": "target",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7533,
                      "line": 200,
                      "column": 25
                    },
                    "end": {
                      "offset": 7539,
                      "line": 200,
                      "column": 31
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7523,
                    "line": 200,
                    "column": 15
                  },
                  "end": {
                    "offset": 7540,
                    "line": 200,
                    "column": 32
                  }
                }
              },
              "then": {
                "type": "BinaryExpression",
                "operator": "&&",
                "left": {
                  "type": "BinaryExpression",
                  "operator": "==",
                  "left": {
                    "type": "NameExpression",
                    "name": "cmds",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7542,
                        "line": 200,
                        "column": 34
                      },
                      "end": {
                        "offset": 7546,
                        "line": 200,
                        "column": 38
                      }
                    }
                  },
                  "right": {
                    "type": "DataTypeAccessExpression",
                    "datatype": "types.Commands.heater",
                    "attr": "Off",
                    "index": null,
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7550,
                        "line": 200,
                        "column": 42
                      },
                      "end": {
                        "offset": 7577,
                        "line": 200,
                        "column": 69
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7542,
                      "line": 200,
                      "column": 34
                    },
                    "end": {
                      "offset": 7577,
                      "line": 200,
                      "column": 69
                    }
                  }
                },
                "right": {
                  "type": "DataTypeAccessExpression",
                  "datatype": "types.Commands.cooler",
                  "attr": "On",
                  "index": null,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7580,
                      "line": 200,
                      "column": 72
                    },
                    "end": {
                      "offset": 7606,
                      "line": 200,
                      "column": 98
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7542,
                    "line": 200,
                    "column": 34
                  },
                  "end": {
                    "offset": 7606,
                    "line": 200,
                    "column": 98
                  }
                }
              },
              "alternate": {
                "type": "BinaryExpression",
                "operator": "&&",
                "left": {
                  "type": "DataTypeAccessExpression",
                  "datatype": "types.Commands.heater",
                  "attr": "On",
                  "index": null,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7608,
                      "line": 200,
                      "column": 100
                    },
                    "end": {
                      "offset": 7634,
                      "line": 200,
                      "column": 126
                    }
                  }
                },
                "right": {
                  "type": "BinaryExpression",
                  "operator": "==",
                  "left": {
                    "type": "NameExpression",
                    "name": "cmds",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7637,
                        "line": 200,
                        "column": 129
                      },
                      "end": {
                        "offset": 7641,
                        "line": 200,
                        "column": 133
                      }
                    }
                  },
                  "right": {
                    "type": "DataTypeAccessExpression",
                    "datatype": "types.Commands.cooler",
                    "attr": "Off",
                    "index": null,
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7645,
                        "line": 200,
                        "column": 137
                      },
                      "end": {
                        "offset": 7674,
                        "line": 201,
                        "column": 3
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7637,
                      "line": 200,
                      "column": 129
                    },
                    "end": {
                      "offset": 7674,
                      "line": 201,
                      "column": 3
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7608,
                    "line": 200,
                    "column": 100
                  },
                  "end": {
                    "offset": 7674,
                    "line": 201,
                    "column": 3
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7523,
                  "line": 200,
                  "column": 15
                },
                "end": {
                  "offset": 7674,
                  "line": 201,
                  "column": 3
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7386,
              "line": 198,
              "column": 2
            },
            "end": {
              "offset": 7675,
              "line": 201,
              "column": 4
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "FahrenheitToCelsiusEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "f",
                "isFlow": false,
                "definition": "FahrenheitTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7713,
                    "line": 202,
                    "column": 37
                  },
                  "end": {
                    "offset": 7739,
                    "line": 202,
                    "column": 63
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "c",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7748,
                    "line": 203,
                    "column": 7
                  },
                  "end": {
                    "offset": 7771,
                    "line": 203,
                    "column": 30
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "BinaryExpression",
              "operator": "==",
              "left": {
                "type": "NameExpression",
                "name": "c",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7790,
                    "line": 204,
                    "column": 15
                  },
                  "end": {
                    "offset": 7791,
                    "line": 204,
                    "column": 16
                  }
                }
              },
              "right": {
                "type": "BinaryExpression",
                "operator": "/",
                "left": {
                  "type": "BinaryExpression",
                  "operator": "*",
                  "left": {
                    "type": "NaturalLiteral",
                    "value": 5,
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7796,
                        "line": 204,
                        "column": 21
                      },
                      "end": {
                        "offset": 7797,
                        "line": 204,
                        "column": 22
                      }
                    }
                  },
                  "right": {
                    "type": "BinaryExpression",
                    "operator": "-",
                    "left": {
                      "type": "NameExpression",
                      "name": "f",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 7799,
                          "line": 204,
                          "column": 24
                        },
                        "end": {
                          "offset": 7800,
                          "line": 204,
                          "column": 25
                        }
                      }
                    },
                    "right": {
                      "type": "NaturalLiteral",
                      "value": 32,
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 7803,
                          "line": 204,
                          "column": 28
                        },
                        "end": {
                          "offset": 7805,
                          "line": 204,
                          "column": 30
                        }
                      }
                    },
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 7799,
                        "line": 204,
                        "column": 24
                      },
                      "end": {
                        "offset": 7805,
                        "line": 204,
                        "column": 30
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7796,
                      "line": 204,
                      "column": 21
                    },
                    "end": {
                      "offset": 7808,
                      "line": 204,
                      "column": 33
                    }
                  }
                },
                "right": {
                  "type": "NaturalLiteral",
                  "value": 9,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 7807,
                      "line": 204,
                      "column": 32
                    },
                    "end": {
                      "offset": 7808,
                      "line": 204,
                      "column": 33
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7796,
                    "line": 204,
                    "column": 21
                  },
                  "end": {
                    "offset": 7808,
                    "line": 204,
                    "column": 33
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7790,
                  "line": 204,
                  "column": 15
                },
                "end": {
                  "offset": 7812,
                  "line": 205,
                  "column": 3
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7678,
              "line": 202,
              "column": 2
            },
            "end": {
              "offset": 7813,
              "line": 205,
              "column": 4
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "CommandHeaterEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "cmds",
                "isFlow": false,
                "definition": "Commands",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7845,
                    "line": 206,
                    "column": 31
                  },
                  "end": {
                    "offset": 7861,
                    "line": 206,
                    "column": 47
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "c",
                "isFlow": false,
                "definition": "Command",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7870,
                    "line": 207,
                    "column": 7
                  },
                  "end": {
                    "offset": 7882,
                    "line": 207,
                    "column": 19
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "BinaryExpression",
              "operator": "==",
              "left": {
                "type": "NameExpression",
                "name": "c",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7901,
                    "line": 208,
                    "column": 15
                  },
                  "end": {
                    "offset": 7902,
                    "line": 208,
                    "column": 16
                  }
                }
              },
              "right": {
                "type": "DataTypeAccessExpression",
                "datatype": "cmds",
                "attr": "heater",
                "index": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7906,
                    "line": 208,
                    "column": 20
                  },
                  "end": {
                    "offset": 7922,
                    "line": 209,
                    "column": 3
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 7901,
                  "line": 208,
                  "column": 15
                },
                "end": {
                  "offset": 7922,
                  "line": 209,
                  "column": 3
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7816,
              "line": 206,
              "column": 2
            },
            "end": {
              "offset": 7923,
              "line": 209,
              "column": 4
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "CommandCoolerEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "cmds",
                "isFlow": false,
                "definition": "Commands",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7955,
                    "line": 210,
                    "column": 31
                  },
                  "end": {
                    "offset": 7971,
                    "line": 210,
                    "column": 47
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "c",
                "isFlow": false,
                "definition": "Command",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 7977,
                    "line": 210,
                    "column": 53
                  },
                  "end": {
                    "offset": 7989,
                    "line": 210,
                    "column": 65
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "BinaryExpression",
              "operator": "==",
              "left": {
                "type": "NameExpression",
                "name": "c",
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8003,
                    "line": 210,
                    "column": 79
                  },
                  "end": {
                    "offset": 8004,
                    "line": 210,
                    "column": 80
                  }
                }
              },
              "right": {
                "type": "DataTypeAccessExpression",
                "datatype": "cmds",
                "attr": "cooler",
                "index": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8008,
                    "line": 210,
                    "column": 84
                  },
                  "end": {
                    "offset": 8021,
                    "line": 210,
                    "column": 97
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8003,
                  "line": 210,
                  "column": 79
                },
                "end": {
                  "offset": 8021,
                  "line": 210,
                  "column": 97
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 7926,
              "line": 210,
              "column": 2
            },
            "end": {
              "offset": 8022,
              "line": 210,
              "column": 98
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "FahrenheitToCelsiusAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "current1",
              "isFlow": false,
              "definition": "FahrenheitTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8060,
                  "line": 211,
                  "column": 37
                },
                "end": {
                  "offset": 8093,
                  "line": 211,
                  "column": 70
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "FahrenheitToCelsiusEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8131,
                  "line": 211,
                  "column": 108
                },
                "end": {
                  "offset": 8167,
                  "line": 211,
                  "column": 144
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8025,
              "line": 211,
              "column": 2
            },
            "end": {
              "offset": 8169,
              "line": 211,
              "column": 146
            }
          }
        },
        {
          "type": "ActionDef",
          "name": "CheckPeresenceToSetTemperatureAN",
          "inParameters": [
            {
              "type": "Pin",
              "name": "detected",
              "isFlow": false,
              "definition": "Boolean",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8219,
                  "line": 212,
                  "column": 48
                },
                "end": {
                  "offset": 8238,
                  "line": 212,
                  "column": 67
                }
              }
            },
            {
              "type": "Pin",
              "name": "userTemp",
              "isFlow": false,
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8240,
                  "line": 212,
                  "column": 69
                },
                "end": {
                  "offset": 8270,
                  "line": 212,
                  "column": 99
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "behaviorDefs": [],
          "dataDefs": [],
          "constraints": [
            {
              "type": "ConstraintUse",
              "kind": "post-condition",
              "definition": "CheckPresenceToSetTemperatureEQ",
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8308,
                  "line": 212,
                  "column": 137
                },
                "end": {
                  "offset": 8354,
                  "line": 212,
                  "column": 183
                }
              }
            }
          ],
          "delegations": [],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8173,
              "line": 212,
              "column": 2
            },
            "end": {
              "offset": 8356,
              "line": 212,
              "column": 185
            }
          }
        },
        {
          "type": "ConstraintDef",
          "name": "CheckPresenceToSetTemperatureEQ",
          "inParameters": [
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "detected",
                "isFlow": false,
                "definition": "Boolean",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8404,
                    "line": 213,
                    "column": 47
                  },
                  "end": {
                    "offset": 8423,
                    "line": 213,
                    "column": 66
                  }
                }
              },
              {
                "type": "Pin",
                "name": "userTemp",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8425,
                    "line": 213,
                    "column": 68
                  },
                  "end": {
                    "offset": 8455,
                    "line": 213,
                    "column": 98
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "outParameters": [
            ":",
            [
              " "
            ],
            "(",
            [
              " "
            ],
            [
              {
                "type": "Pin",
                "name": "target",
                "isFlow": false,
                "definition": "CelsiusTemperature",
                "arrayIndex": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8461,
                    "line": 213,
                    "column": 104
                  },
                  "end": {
                    "offset": 8489,
                    "line": 213,
                    "column": 132
                  }
                }
              }
            ],
            [],
            ")"
          ],
          "members": [],
          "equation": [
            "equation",
            [
              " "
            ],
            "=",
            [
              " "
            ],
            {
              "type": "ConditionalExpression",
              "condition": {
                "type": "BinaryExpression",
                "operator": "==",
                "left": {
                  "type": "NameExpression",
                  "name": "detected",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8503,
                      "line": 213,
                      "column": 146
                    },
                    "end": {
                      "offset": 8511,
                      "line": 213,
                      "column": 154
                    }
                  }
                },
                "right": {
                  "type": "NameExpression",
                  "name": "true",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8515,
                      "line": 213,
                      "column": 158
                    },
                    "end": {
                      "offset": 8519,
                      "line": 213,
                      "column": 162
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8503,
                    "line": 213,
                    "column": 146
                  },
                  "end": {
                    "offset": 8520,
                    "line": 213,
                    "column": 163
                  }
                }
              },
              "then": {
                "type": "BinaryExpression",
                "operator": "==",
                "left": {
                  "type": "NameExpression",
                  "name": "target",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8522,
                      "line": 213,
                      "column": 165
                    },
                    "end": {
                      "offset": 8528,
                      "line": 213,
                      "column": 171
                    }
                  }
                },
                "right": {
                  "type": "NameExpression",
                  "name": "userTemp",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8532,
                      "line": 213,
                      "column": 175
                    },
                    "end": {
                      "offset": 8540,
                      "line": 213,
                      "column": 183
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8522,
                    "line": 213,
                    "column": 165
                  },
                  "end": {
                    "offset": 8541,
                    "line": 213,
                    "column": 184
                  }
                }
              },
              "alternate": {
                "type": "BinaryExpression",
                "operator": "==",
                "left": {
                  "type": "NameExpression",
                  "name": "target",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8543,
                      "line": 213,
                      "column": 186
                    },
                    "end": {
                      "offset": 8549,
                      "line": 213,
                      "column": 192
                    }
                  }
                },
                "right": {
                  "type": "NaturalLiteral",
                  "value": 2,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8553,
                      "line": 213,
                      "column": 196
                    },
                    "end": {
                      "offset": 8554,
                      "line": 213,
                      "column": 197
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8543,
                    "line": 213,
                    "column": 186
                  },
                  "end": {
                    "offset": 8555,
                    "line": 213,
                    "column": 198
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8503,
                  "line": 213,
                  "column": 146
                },
                "end": {
                  "offset": 8555,
                  "line": 213,
                  "column": 198
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8359,
              "line": 213,
              "column": 2
            },
            "end": {
              "offset": 8556,
              "line": 213,
              "column": 199
            }
          }
        },
        {
          "type": "Executable",
          "name": "CommandCoolerEx",
          "params": [
            {
              "type": "TypeUse",
              "name": "cmds",
              "definition": "Commands",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8593,
                  "line": 214,
                  "column": 36
                },
                "end": {
                  "offset": 8606,
                  "line": 214,
                  "column": 49
                }
              }
            }
          ],
          "returnType": "Command",
          "properties": [],
          "body": [
            {
              "type": "ReturnStatement",
              "value": {
                "type": "DataTypeAccessExpression",
                "datatype": "cmds",
                "attr": "cooler",
                "index": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8628,
                    "line": 214,
                    "column": 71
                  },
                  "end": {
                    "offset": 8641,
                    "line": 214,
                    "column": 84
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8621,
                  "line": 214,
                  "column": 64
                },
                "end": {
                  "offset": 8642,
                  "line": 214,
                  "column": 85
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8559,
              "line": 214,
              "column": 2
            },
            "end": {
              "offset": 8644,
              "line": 214,
              "column": 87
            }
          }
        },
        {
          "type": "Executable",
          "name": "CommandHeaterEx",
          "params": [
            {
              "type": "TypeUse",
              "name": "cmds",
              "definition": "Commands",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8681,
                  "line": 215,
                  "column": 36
                },
                "end": {
                  "offset": 8694,
                  "line": 215,
                  "column": 49
                }
              }
            }
          ],
          "returnType": "Command",
          "properties": [],
          "body": [
            {
              "type": "ReturnStatement",
              "value": {
                "type": "DataTypeAccessExpression",
                "datatype": "cmds",
                "attr": "heater",
                "index": null,
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8716,
                    "line": 215,
                    "column": 71
                  },
                  "end": {
                    "offset": 8729,
                    "line": 215,
                    "column": 84
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8709,
                  "line": 215,
                  "column": 64
                },
                "end": {
                  "offset": 8730,
                  "line": 215,
                  "column": 85
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8647,
              "line": 215,
              "column": 2
            },
            "end": {
              "offset": 8732,
              "line": 215,
              "column": 87
            }
          }
        },
        {
          "type": "Executable",
          "name": "FahrenheitToCelsiusEx",
          "params": [
            {
              "type": "TypeUse",
              "name": "f",
              "definition": "FahrenheitTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8774,
                  "line": 216,
                  "column": 42
                },
                "end": {
                  "offset": 8797,
                  "line": 216,
                  "column": 65
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "body": [
            {
              "type": "ReturnStatement",
              "value": {
                "type": "BinaryExpression",
                "operator": "/",
                "left": {
                  "type": "BinaryExpression",
                  "operator": "*",
                  "left": {
                    "type": "NaturalLiteral",
                    "value": 5,
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 8830,
                        "line": 216,
                        "column": 98
                      },
                      "end": {
                        "offset": 8831,
                        "line": 216,
                        "column": 99
                      }
                    }
                  },
                  "right": {
                    "type": "BinaryExpression",
                    "operator": "-",
                    "left": {
                      "type": "NameExpression",
                      "name": "f",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 8833,
                          "line": 216,
                          "column": 101
                        },
                        "end": {
                          "offset": 8834,
                          "line": 216,
                          "column": 102
                        }
                      }
                    },
                    "right": {
                      "type": "NaturalLiteral",
                      "value": 32,
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 8837,
                          "line": 216,
                          "column": 105
                        },
                        "end": {
                          "offset": 8839,
                          "line": 216,
                          "column": 107
                        }
                      }
                    },
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 8833,
                        "line": 216,
                        "column": 101
                      },
                      "end": {
                        "offset": 8839,
                        "line": 216,
                        "column": 107
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8830,
                      "line": 216,
                      "column": 98
                    },
                    "end": {
                      "offset": 8842,
                      "line": 216,
                      "column": 110
                    }
                  }
                },
                "right": {
                  "type": "NaturalLiteral",
                  "value": 9,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8841,
                      "line": 216,
                      "column": 109
                    },
                    "end": {
                      "offset": 8842,
                      "line": 216,
                      "column": 110
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8830,
                    "line": 216,
                    "column": 98
                  },
                  "end": {
                    "offset": 8842,
                    "line": 216,
                    "column": 110
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8823,
                  "line": 216,
                  "column": 91
                },
                "end": {
                  "offset": 8844,
                  "line": 216,
                  "column": 112
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8734,
              "line": 216,
              "column": 2
            },
            "end": {
              "offset": 8846,
              "line": 216,
              "column": 114
            }
          }
        },
        {
          "type": "Executable",
          "name": "CalculateAverageTemperatureEx",
          "params": [
            {
              "type": "TypeUse",
              "name": "temp1",
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8896,
                  "line": 217,
                  "column": 50
                },
                "end": {
                  "offset": 8920,
                  "line": 217,
                  "column": 74
                }
              }
            },
            {
              "type": "TypeUse",
              "name": "temp2",
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8924,
                  "line": 217,
                  "column": 78
                },
                "end": {
                  "offset": 8948,
                  "line": 217,
                  "column": 102
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "body": [
            {
              "type": "ReturnStatement",
              "value": {
                "type": "BinaryExpression",
                "operator": "/",
                "left": {
                  "type": "BinaryExpression",
                  "operator": "+",
                  "left": {
                    "type": "NameExpression",
                    "name": "temp1",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 8981,
                        "line": 217,
                        "column": 135
                      },
                      "end": {
                        "offset": 8986,
                        "line": 217,
                        "column": 140
                      }
                    }
                  },
                  "right": {
                    "type": "NameExpression",
                    "name": "temp2",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 8989,
                        "line": 217,
                        "column": 143
                      },
                      "end": {
                        "offset": 8994,
                        "line": 217,
                        "column": 148
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8981,
                      "line": 217,
                      "column": 135
                    },
                    "end": {
                      "offset": 8994,
                      "line": 217,
                      "column": 148
                    }
                  }
                },
                "right": {
                  "type": "NaturalLiteral",
                  "value": 2,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 8996,
                      "line": 217,
                      "column": 150
                    },
                    "end": {
                      "offset": 8997,
                      "line": 217,
                      "column": 151
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 8980,
                    "line": 217,
                    "column": 134
                  },
                  "end": {
                    "offset": 8997,
                    "line": 217,
                    "column": 151
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 8973,
                  "line": 217,
                  "column": 127
                },
                "end": {
                  "offset": 8999,
                  "line": 217,
                  "column": 153
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 8848,
              "line": 217,
              "column": 2
            },
            "end": {
              "offset": 9001,
              "line": 217,
              "column": 155
            }
          }
        },
        {
          "type": "Executable",
          "name": "CheckPresenceToSetTemperature",
          "params": [
            {
              "type": "TypeUse",
              "name": "presence",
              "definition": "Boolean",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9051,
                  "line": 218,
                  "column": 50
                },
                "end": {
                  "offset": 9067,
                  "line": 218,
                  "column": 66
                }
              }
            },
            {
              "type": "TypeUse",
              "name": "userTemp",
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9072,
                  "line": 218,
                  "column": 71
                },
                "end": {
                  "offset": 9099,
                  "line": 218,
                  "column": 98
                }
              }
            }
          ],
          "returnType": "CelsiusTemperature",
          "properties": [],
          "body": [
            {
              "type": "IfBlockStatement",
              "main_if": {
                "type": "IfStatement",
                "condition": {
                  "type": "BinaryExpression",
                  "operator": "==",
                  "left": {
                    "type": "NameExpression",
                    "name": "presence",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9127,
                        "line": 218,
                        "column": 126
                      },
                      "end": {
                        "offset": 9135,
                        "line": 218,
                        "column": 134
                      }
                    }
                  },
                  "right": {
                    "type": "NameExpression",
                    "name": "true",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9139,
                        "line": 218,
                        "column": 138
                      },
                      "end": {
                        "offset": 9143,
                        "line": 218,
                        "column": 142
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9127,
                      "line": 218,
                      "column": 126
                    },
                    "end": {
                      "offset": 9143,
                      "line": 218,
                      "column": 142
                    }
                  }
                },
                "body": {
                  "type": "ReturnStatement",
                  "value": {
                    "type": "NameExpression",
                    "name": "userTemp",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9152,
                        "line": 218,
                        "column": 151
                      },
                      "end": {
                        "offset": 9160,
                        "line": 218,
                        "column": 159
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9145,
                      "line": 218,
                      "column": 144
                    },
                    "end": {
                      "offset": 9161,
                      "line": 218,
                      "column": 160
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 9124,
                    "line": 218,
                    "column": 123
                  },
                  "end": {
                    "offset": 9161,
                    "line": 218,
                    "column": 160
                  }
                }
              },
              "else_if": [],
              "else_stmt": {
                "type": "ReturnStatement",
                "value": {
                  "type": "NaturalLiteral",
                  "value": 2,
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9174,
                      "line": 218,
                      "column": 173
                    },
                    "end": {
                      "offset": 9175,
                      "line": 218,
                      "column": 174
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 9167,
                    "line": 218,
                    "column": 166
                  },
                  "end": {
                    "offset": 9176,
                    "line": 218,
                    "column": 175
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9124,
                  "line": 218,
                  "column": 123
                },
                "end": {
                  "offset": 9176,
                  "line": 218,
                  "column": 175
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 9003,
              "line": 218,
              "column": 2
            },
            "end": {
              "offset": 9178,
              "line": 218,
              "column": 177
            }
          }
        },
        {
          "type": "Executable",
          "name": "CompareTemperatureEx",
          "params": [
            {
              "type": "TypeUse",
              "name": "target",
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9219,
                  "line": 219,
                  "column": 41
                },
                "end": {
                  "offset": 9244,
                  "line": 219,
                  "column": 66
                }
              }
            },
            {
              "type": "TypeUse",
              "name": "average",
              "definition": "CelsiusTemperature",
              "arrayIndex": null,
              "body": null,
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9249,
                  "line": 219,
                  "column": 71
                },
                "end": {
                  "offset": 9275,
                  "line": 219,
                  "column": 97
                }
              }
            }
          ],
          "returnType": "Commands",
          "properties": [],
          "body": [
            {
              "type": "VariableDecl",
              "name": "heater",
              "definition": "Command",
              "arrayIndex": null,
              "value": [
                "=",
                [
                  " "
                ],
                {
                  "type": "EnumValueLiteral",
                  "enumName": "types.Command",
                  "value": "Off",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9311,
                      "line": 219,
                      "column": 133
                    },
                    "end": {
                      "offset": 9329,
                      "line": 219,
                      "column": 151
                    }
                  }
                }
              ],
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9290,
                  "line": 219,
                  "column": 112
                },
                "end": {
                  "offset": 9330,
                  "line": 219,
                  "column": 152
                }
              }
            },
            {
              "type": "VariableDecl",
              "name": "cooler",
              "definition": "Command",
              "arrayIndex": null,
              "value": [
                "=",
                [
                  " "
                ],
                {
                  "type": "EnumValueLiteral",
                  "enumName": "types.Command",
                  "value": "Off",
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9352,
                      "line": 219,
                      "column": 174
                    },
                    "end": {
                      "offset": 9370,
                      "line": 219,
                      "column": 192
                    }
                  }
                }
              ],
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9331,
                  "line": 219,
                  "column": 153
                },
                "end": {
                  "offset": 9371,
                  "line": 219,
                  "column": 193
                }
              }
            },
            {
              "type": "IfBlockStatement",
              "main_if": {
                "type": "IfStatement",
                "condition": {
                  "type": "BinaryExpression",
                  "operator": ">",
                  "left": {
                    "type": "NameExpression",
                    "name": "average",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9375,
                        "line": 219,
                        "column": 197
                      },
                      "end": {
                        "offset": 9382,
                        "line": 219,
                        "column": 204
                      }
                    }
                  },
                  "right": {
                    "type": "NameExpression",
                    "name": "target",
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9385,
                        "line": 219,
                        "column": 207
                      },
                      "end": {
                        "offset": 9391,
                        "line": 219,
                        "column": 213
                      }
                    }
                  },
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9375,
                      "line": 219,
                      "column": 197
                    },
                    "end": {
                      "offset": 9391,
                      "line": 219,
                      "column": 213
                    }
                  }
                },
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "Assignment",
                      "left": "heater",
                      "right": {
                        "type": "EnumValueLiteral",
                        "enumName": "types.Command",
                        "value": "Off",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 9403,
                            "line": 219,
                            "column": 225
                          },
                          "end": {
                            "offset": 9421,
                            "line": 219,
                            "column": 243
                          }
                        }
                      },
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 9394,
                          "line": 219,
                          "column": 216
                        },
                        "end": {
                          "offset": 9422,
                          "line": 219,
                          "column": 244
                        }
                      }
                    },
                    {
                      "type": "Assignment",
                      "left": "cooler",
                      "right": {
                        "type": "EnumValueLiteral",
                        "enumName": "types.Command",
                        "value": "On",
                        "location": {
                          "source": {
                            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                          },
                          "start": {
                            "offset": 9432,
                            "line": 219,
                            "column": 254
                          },
                          "end": {
                            "offset": 9449,
                            "line": 219,
                            "column": 271
                          }
                        }
                      },
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 9423,
                          "line": 219,
                          "column": 245
                        },
                        "end": {
                          "offset": 9451,
                          "line": 219,
                          "column": 273
                        }
                      }
                    }
                  ],
                  "location": {
                    "source": {
                      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                    },
                    "start": {
                      "offset": 9393,
                      "line": 219,
                      "column": 215
                    },
                    "end": {
                      "offset": 9453,
                      "line": 219,
                      "column": 275
                    }
                  }
                },
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 9372,
                    "line": 219,
                    "column": 194
                  },
                  "end": {
                    "offset": 9453,
                    "line": 219,
                    "column": 275
                  }
                }
              },
              "else_if": [],
              "else_stmt": {
                "type": "BlockStatement",
                "body": [
                  {
                    "type": "Assignment",
                    "left": "heater",
                    "right": {
                      "type": "EnumValueLiteral",
                      "enumName": "types.Command",
                      "value": "On",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 9469,
                          "line": 219,
                          "column": 291
                        },
                        "end": {
                          "offset": 9486,
                          "line": 219,
                          "column": 308
                        }
                      }
                    },
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9460,
                        "line": 219,
                        "column": 282
                      },
                      "end": {
                        "offset": 9487,
                        "line": 219,
                        "column": 309
                      }
                    }
                  },
                  {
                    "type": "Assignment",
                    "left": "cooler",
                    "right": {
                      "type": "EnumValueLiteral",
                      "enumName": "types.Command",
                      "value": "Off",
                      "location": {
                        "source": {
                          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                        },
                        "start": {
                          "offset": 9497,
                          "line": 219,
                          "column": 319
                        },
                        "end": {
                          "offset": 9515,
                          "line": 219,
                          "column": 337
                        }
                      }
                    },
                    "location": {
                      "source": {
                        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                      },
                      "start": {
                        "offset": 9488,
                        "line": 219,
                        "column": 310
                      },
                      "end": {
                        "offset": 9517,
                        "line": 219,
                        "column": 339
                      }
                    }
                  }
                ],
                "location": {
                  "source": {
                    "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                    "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                  },
                  "start": {
                    "offset": 9459,
                    "line": 219,
                    "column": 281
                  },
                  "end": {
                    "offset": 9518,
                    "line": 219,
                    "column": 340
                  }
                }
              },
              "location": {
                "source": {
                  "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
                  "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
                },
                "start": {
                  "offset": 9372,
                  "line": 219,
                  "column": 194
                },
                "end": {
                  "offset": 9518,
                  "line": 219,
                  "column": 340
                }
              }
            }
          ],
          "location": {
            "source": {
              "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
              "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
            },
            "start": {
              "offset": 9180,
              "line": 219,
              "column": 2
            },
            "end": {
              "offset": 9520,
              "line": 219,
              "column": 342
            }
          }
        }
      ],
      "location": {
        "source": {
          "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
          "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
        },
        "start": {
          "offset": 1758,
          "line": 56,
          "column": 3
        },
        "end": {
          "offset": 9522,
          "line": 219,
          "column": 344
        }
      }
    }
  ],
  "allocation": {
    "type": "AllocationTable",
    "allocations": [
      {
        "type": "ActivityAllocation",
        "source": "FahrenheitToCelsiusAC",
        "target": "FahrenheitToCelsiusCN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9544,
            "line": 222,
            "column": 3
          },
          "end": {
            "offset": 9599,
            "line": 222,
            "column": 58
          }
        }
      },
      {
        "type": "ActivityAllocation",
        "source": "DecideCommandAC",
        "target": "CommanderCP",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9603,
            "line": 223,
            "column": 3
          },
          "end": {
            "offset": 9642,
            "line": 223,
            "column": 42
          }
        }
      },
      {
        "type": "ActivityAllocation",
        "source": "CheckPresenceToSetTemperatureAC",
        "target": "PresenceCheckerCP",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9646,
            "line": 224,
            "column": 3
          },
          "end": {
            "offset": 9707,
            "line": 224,
            "column": 64
          }
        }
      },
      {
        "type": "ActivityAllocation",
        "source": "CalculateAverageTemperatureAC",
        "target": "SensorsMonitorCP",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9711,
            "line": 225,
            "column": 3
          },
          "end": {
            "offset": 9769,
            "line": 225,
            "column": 61
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "FahrenheitToCelsiusEx",
        "target": "FahrenheitToCelsiusAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9773,
            "line": 226,
            "column": 3
          },
          "end": {
            "offset": 9830,
            "line": 226,
            "column": 60
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "CompareTemperatureEx",
        "target": "CompareTemperatureAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9834,
            "line": 227,
            "column": 3
          },
          "end": {
            "offset": 9889,
            "line": 227,
            "column": 58
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "CommandHeaterEx",
        "target": "CommandHeaterAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9893,
            "line": 228,
            "column": 3
          },
          "end": {
            "offset": 9938,
            "line": 228,
            "column": 48
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "CommandCoolerEx",
        "target": "CommandCoolerAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9942,
            "line": 229,
            "column": 3
          },
          "end": {
            "offset": 9987,
            "line": 229,
            "column": 48
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "CheckPresenceToSetTemperature",
        "target": "CheckPeresenceToSetTemperatureAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 9991,
            "line": 230,
            "column": 3
          },
          "end": {
            "offset": 10067,
            "line": 230,
            "column": 79
          }
        }
      },
      {
        "type": "ExecutableAllocation",
        "source": "CalculateAverageTemperatureEx",
        "target": "CalculateAverageTemperatureAN",
        "location": {
          "source": {
            "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
            "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
          },
          "start": {
            "offset": 10071,
            "line": 231,
            "column": 3
          },
          "end": {
            "offset": 10144,
            "line": 231,
            "column": 76
          }
        }
      }
    ],
    "location": {
      "source": {
        "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
        "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
      },
      "start": {
        "offset": 9527,
        "line": 221,
        "column": 2
      },
      "end": {
        "offset": 10147,
        "line": 232,
        "column": 3
      }
    }
  },
  "location": {
    "source": {
      "source": "/Users/tales/desenv/SysAdlWebStudio/tales/v0.4/RTC.sysadl",
      "text": "Model SysADLModel ; \npackage types {\n  value type Int {}\n  value type Boolean {}\n  value type String {}\n  value type Void {}\n  value type Real {}\n  enum Command {On , Off }\n  datatype Commands {attributes : heater : Command ; cooler : Command ; }\n  dimension Temperature unit Celsius {dimension = Temperature }\n  unit Fahrenheit {dimension = Temperature }\n  value type temperature extends Real { dimension = Temperature }\n  value type FahrenheitTemperature extends temperature { unit = Fahrenheit dimension = Temperature }\n  value type CelsiusTemperature extends temperature { unit = Celsius dimension = Temperature } \n}\npackage Ports { import types ; port def FTemperatureOPT { flow out FahrenheitTemperature }\n  port def PresenceIPT { flow in Boolean }\n  port def PresenceOPT { flow out Boolean }\n  port def CTemperatureIPT { flow in CelsiusTemperature }\n  port def CommandIPT { flow in Command }\n  port def CommandOPT { flow out Command }\n  port def CTemperatureOPT { flow out CelsiusTemperature }\n}\npackage Connectors { \n  \timport types ; \n  \timport Ports ; \n  \tconnector def FahrenheitToCelsiusCN { \n  \t\tparticipants : \n  \t\t\t~ Ft : FTemperatureOPT ; \n  \t\t\t~ Ct : CTemperatureIPT ; \n\t\tflows : \n\t\t\tFahrenheitTemperature from Ft to Ct\n  \t}\n  connector def PresenceCN { \n  \t\tparticipants : \n  \t\t\t~ pOut : PresenceOPT ; \n  \t\t\t~ pIn : PresenceIPT ; \n  \t\tflows : \n  \t\t\tBoolean from pOut to pIn\n  }\n  connector def CommandCN { \n  \t\tparticipants : \n  \t\t\t~ commandOut : CommandOPT ; \n  \t\t\t~ commandIn : CommandIPT ; \n  \t\tflows : \n  \t\t\tCommand from commandOut to commandIn\n  }\n  connector def CTemperatureCN { \n  \t\tparticipants : \n  \t\t\t~ CtOut : CTemperatureOPT ; \n  \t\t\t~ ctIn : CTemperatureIPT ; \n  \t\tflows : \n  \t\t\tCelsiusTemperature from CtOut to ctIn\n  }\n  }\n  package Components { \n  \timport Connectors ; \n  \timport types ; \n  \timport Ports ;\n\tcomponent def RTCSystemCFD {\t\n\t\t configuration {\t \n\t\t \tcomponents : \n\t\t \t\ts1 : TemperatureSensorCP {\t using ports : current1 : FTemperatureOPT ; }\n\t  \t\t\ts2 : TemperatureSensorCP {\t using ports : current2 : FTemperatureOPT ; }\n\t\t\t\ts3 : PresenceSensorCP {\t using ports : detectedS : PresenceOPT ; }\n\t  \t\t\tui : UserInterfaceCP {\t using ports : desired : CTemperatureOPT ; }\n\t  \t\t\ta2 : CoolerCP {\t using ports : controllerC : CommandIPT ; }\n\t  \t\t\ta1 : HeaterCP {\t using ports : controllerH : CommandIPT ; }\n\t  \t\t\trtc : RoomTemperatureControllerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n\t  \t\t\t\t\tlocaltemp1 : CTemperatureIPT ; \n\t  \t\t\t\t\tlocalTemp2 : CTemperatureIPT ; \n\t  \t\t\t\t\tuserTemp : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ; \n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\tc1 : FahrenheitToCelsiusCN bindings current1 = localtemp1 ; \n\t  \t\t\tuc : CTemperatureCN bindings desired = userTemp ; \n\t  \t\t\tcc2 : CommandCN bindings cooling = controllerC ; \n\t  \t\t\tpc : PresenceCN bindings detectedS = detected ; \n\t  \t\t\tc2 : FahrenheitToCelsiusCN bindings current2 = localTemp2 ; \n\t  \t\t\tcc1 : CommandCN bindings heating = controllerH ; \n\t  \t}\n\t  }\n\n\tcomponent def RoomTemperatureControllerCP {\t \n\t\tports : detectedRTC : PresenceIPT ; localtemp1 : CTemperatureIPT ; localTemp2 : CTemperatureIPT ; userTempRTC : CTemperatureIPT ; heatingRTC : CommandOPT ; coolingRTC : CommandOPT ; \n\t\tconfiguration {\t \n\t\t\tcomponents : \n\t\t\t\tsm : SensorsMonitorCP {\t \n\t\t\t\t\tusing ports : s1 : CTemperatureIPT ; \n\t\t\t\t\t\ts2 : CTemperatureIPT ; \n\t\t\t\t\t\taverage : CTemperatureOPT ;\n\t\t\t\t}\n\t  \t\t\tcm : CommanderCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\ttarget2 : CTemperatureIPT ; \n\t  \t\t\t\t\taverage2 : CTemperatureIPT ; \n\t  \t\t\t\t\theating : CommandOPT ; \n\t  \t\t\t\t\tcooling : CommandOPT ;\n\t  \t\t\t}\n\t  \t\t\tpc : PresenceCheckerCP {\t \n\t  \t\t\t\tusing ports : \n\t  \t\t\t\t\tdetected : PresenceIPT ; \n  \t\t\t\t\t\tuserTemp : CTemperatureIPT ; \n  \t\t\t\t\t\ttarget : CTemperatureOPT ;\n\t  \t\t\t}\n\t  \t\tconnectors : \n\t  \t\t\ttarget : CTemperatureCN bindings target = target2 ; \n\t  \t\t\taverage : CTemperatureCN bindings average = average2 ; \n  \t\t\tdelegations :\n  \t\t\t\tuserTemp to userTempRTC \n  \t\t\t\tdetected to detectedRTC \n  \t\t\t\ts1 to localtemp1 \n  \t\t\t\ts2 to localTemp2 \n  \t\t\t\theating to heatingRTC \n  \t\t\t\tcooling to coolingRTC \n  \t\t}\n\t  } \n\tboundary component def TemperatureSensorCP {\t \n\t  \t\tports : current : FTemperatureOPT ;\n\t  } \n\tboundary component def PresenceSensorCP {\t \n\t  \t\tports : detected : PresenceOPT ;\n\t  } \n\tboundary component def UserInterfaceCP {\t \n\t  \t\tports : desired : CTemperatureOPT ;\n\t  } \n\tboundary component def HeaterCP {\t \n\t  \t\tports : controllerH : CommandIPT ;\n\t  } \n\tboundary component def CoolerCP {\t \n\t  \t\tports : controllerC : CommandIPT ;\n\t  }\n\tcomponent def PresenceCheckerCP {\t \n\t\tports : detected : PresenceIPT ; userTemp : CTemperatureIPT ; target : CTemperatureOPT ;\n\t}\n\n\tcomponent def CommanderCP {\t \n\t\tports : target2 : CTemperatureIPT ; average2 : CTemperatureIPT ; heating : CommandOPT ; cooling : CommandOPT ;\n\t}\n\n\tcomponent def SensorsMonitorCP { \n\t\tports : s1 : CTemperatureIPT ; s2 : CTemperatureIPT ; average : CTemperatureOPT ;\n\t}\n\t\n\tconstraint CalculateAverageTemperatureEQ ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : ( av : CelsiusTemperature ) {\n\t\tequation = av == (t1 + t2)/2\n\t} \n\tactivity def CalculateAverageTemperatureAC ( s1 : CelsiusTemperature ) ( s2 : CelsiusTemperature ) : ( average : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CalcAvTemp : CalculateAverageTemperatureAN { \n\t\t\t\tusing pins : s1 : CelsiusTemperature ; \n\t\t\t\ts2 : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate s1 to s1 \n\t\t\tdelegate s2 to s2 \n\t\t\tdelegate average to CalcAvTemp\n\t\t}\n\t} \n\taction def CalculateAverageTemperatureAN ( t1 : CelsiusTemperature , t2 : CelsiusTemperature ) : CelsiusTemperature { \n\t\tconstraint : post-condition CalculateAverageTemperatureEQ\n\t} \n\tactivity def CheckPresenceToSetTemperatureAC ( detected : Boolean ) ( userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) { \n\t\tbody { \n\t\t\tactions : CheckPeresenceToSetTemperatureAN : CheckPeresenceToSetTemperatureAN { \n\t\t\t\tusing pins : \n\t\t\t\t\tdetected : Boolean ; \n\t\t\t\t\tuserTemp : CelsiusTemperature ;\n\t\t\t} \n\t\t\tdelegate detected to detected \n\t\t\tdelegate userTemp to userTemp \n\t\t\tdelegate target to CheckPeresenceToSetTemperatureAN\n\t\t}\n\t} \n\tactivity def DecideCommandAC ( average2 : CelsiusTemperature ) ( target2 : CelsiusTemperature ) : ( cooling : Command , heating : Command ) { \n\t\tbody { \n\t\t\tactions : ct : CompareTemperatureAN { using pins : average2 : CelsiusTemperature ; target2 : CelsiusTemperature ; } cmdH : CommandHeaterAN { using pins : cmdsH : Commands ; } cmdC : CommandCoolerAN { using pins : cmdsC : Commands ; } delegate average2 to average2 delegate target2 to target2 delegate heating to cmdH delegate cooling to cmdC flow from ct to cmdsH flow from ct to cmdsC\n\t\t}\n\t} \n\tactivity def FahrenheitToCelsiusAC ( current1 : FahrenheitTemperature ) : ( loalTemp1 : CelsiusTemperature ) { \n\t\tbody { actions : FtC : FahrenheitToCelsiusAN { using pins : current1 : FahrenheitTemperature ; } delegate loalTemp1 to FtC delegate current1 to current1 }\n\t} \n\taction def CompareTemperatureAN (average2 : CelsiusTemperature , target2 : CelsiusTemperature) \n\t\t: Commands { \n\t\t\tconstraint : post-condition CompareTemperatureEQ \n\t\t} \n\taction def CommandHeaterAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandHeaterEQ\n\t\t} \n\taction def CommandCoolerAN ( cmds : Commands ) \n\t\t: Command { \n\t\t\tconstraint : post-condition CommandCoolerEQ\n\t\t} \n\tconstraint CompareTemperatureEQ ( target : CelsiusTemperature , average : CelsiusTemperature ) \n\t\t: ( cmds : Commands ) { \n\t\t\tequation = average > target ? cmds == types.Commands.heater->Off && types.Commands.cooler->On : types.Commands.heater->On && cmds == types.Commands.cooler->Off\n\t\t} \n\tconstraint FahrenheitToCelsiusEQ ( f : FahrenheitTemperature ) \n\t\t: ( c : CelsiusTemperature ) { \n\t\t\tequation = c == (5*(f - 32)/9)\n\t\t} \n\tconstraint CommandHeaterEQ ( cmds : Commands ) \n\t\t: ( c : Command ) { \n\t\t\tequation = c == cmds->heater \n\t\t} \n\tconstraint CommandCoolerEQ ( cmds : Commands ) : ( c : Command ) {equation = c == cmds->cooler } \n\taction def FahrenheitToCelsiusAN ( current1 : FahrenheitTemperature ) : CelsiusTemperature { constraint : post-condition FahrenheitToCelsiusEQ } \t\n\taction def CheckPeresenceToSetTemperatureAN ( detected : Boolean , userTemp : CelsiusTemperature ) : CelsiusTemperature { constraint : post-condition CheckPresenceToSetTemperatureEQ } \n\tconstraint CheckPresenceToSetTemperatureEQ ( detected : Boolean , userTemp : CelsiusTemperature ) : ( target : CelsiusTemperature ) {equation = detected == true ? target == userTemp : target == 2 } \n\texecutable def CommandCoolerEx(in cmds:Commands): out Command{return cmds->cooler ; } \n\texecutable def CommandHeaterEx(in cmds:Commands): out Command{return cmds->heater ; }\n\texecutable def FahrenheitToCelsiusEx(in f:FahrenheitTemperature): out CelsiusTemperature{return 5*(f - 32)/9 ; }\n\texecutable def CalculateAverageTemperatureEx(in temp1:CelsiusTemperature,in temp2:CelsiusTemperature):out CelsiusTemperature{return (temp1 + temp2)/2 ; }\n\texecutable def CheckPresenceToSetTemperature(in presence:Boolean, in userTemp:CelsiusTemperature):out CelsiusTemperature{if(presence == true) return userTemp; else return 2; }\n\texecutable def CompareTemperatureEx(in target:CelsiusTemperature, in average:CelsiusTemperature):out Commands{let heater:Command = types.Command::Off; let cooler:Command = types.Command::Off; if(average > target) {heater = types.Command::Off; cooler = types.Command::On ; } else {heater = types.Command::On; cooler = types.Command::Off ;} } } \n\t\n\tallocations { \n\t\tactivity FahrenheitToCelsiusAC to FahrenheitToCelsiusCN \n\t\tactivity DecideCommandAC to CommanderCP \n\t\tactivity CheckPresenceToSetTemperatureAC to PresenceCheckerCP \n\t\tactivity CalculateAverageTemperatureAC to SensorsMonitorCP \n\t\texecutable FahrenheitToCelsiusEx to FahrenheitToCelsiusAN \n\t\texecutable CompareTemperatureEx to CompareTemperatureAN \n\t\texecutable CommandHeaterEx to CommandHeaterAN \n\t\texecutable CommandCoolerEx to CommandCoolerAN \n\t\texecutable CheckPresenceToSetTemperature to CheckPeresenceToSetTemperatureAN \n\t\texecutable CalculateAverageTemperatureEx to CalculateAverageTemperatureAN\n\t}"
    },
    "start": {
      "offset": 0,
      "line": 1,
      "column": 1
    },
    "end": {
      "offset": 10147,
      "line": 232,
      "column": 3
    }
  }
}